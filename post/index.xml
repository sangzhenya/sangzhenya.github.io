<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 新月的博客</title>
    <link>https://programya.com/post/</link>
    <description>Recent content in Posts on 新月的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 11 Mar 2020 09:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://programya.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java JNDI</title>
      <link>https://programya.com/post/Java/JVM/Java-JNDI/</link>
      <pubDate>Wed, 11 Mar 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-JNDI/</guid>
      <description>JNDI 即 Java Naming and Direcotry Interface 即 Java 命名与目录接口。是为 Java 编程的客户端提供的一个统一的命名服务和目录系统接口，不依赖于任何特定的服务实现。JDNI 的架构包含一个 API和一个 service provider interface(SPI)。Java 程序使用 JNDI API 去访问不同的命名服务和目录系统接口。SPI 则使得不同的命名服务和目录系统</description>
    </item>
    
    <item>
      <title>Java JVM</title>
      <link>https://programya.com/post/Java/JVM/Java-JVM/</link>
      <pubDate>Tue, 03 Mar 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-JVM/</guid>
      <description>MinorGC 的过程 复制 &amp;ndash;&amp;gt; 清空 &amp;ndash;&amp;gt; 互换 eden, SurviorFrom 复制到 SurviorTo, 年龄 + 1 首先 当 Eden 区满的时候回触发一次 GC，把仍然存活的对象复制到 SurviorFrom 区，当 Eden 去再次触发GC的时候会扫描 Eden区和From区域，对这个两个区域进行垃圾回收，经过这次回收后还存活的对象则直接复制到 To 区域（如果对象的年龄已经达到了老年的标准，则复制到</description>
    </item>
    
    <item>
      <title>Java HotSpot GC 算法实现</title>
      <link>https://programya.com/post/Java/JVM/Java-HotSpot-GC-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 01 Mar 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-HotSpot-GC-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>枚举根节点 可达性分析对执行时间的敏感体现在 GC 停顿上，因为分析工作必须在一个能确保一致性的快照中进行，即整个分析期间整个执行系统看起来就像冻结在某个时间点上，不能出现分析过程中对象引用关系还在不断变化的情况，否则分析结果的准确性就无法得到保证。这也是导致 GC 进行时必须停顿所有 Java 执行线</description>
    </item>
    
    <item>
      <title>Java GC 2</title>
      <link>https://programya.com/post/Java/JVM/Java-GC-2/</link>
      <pubDate>Tue, 25 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-GC-2/</guid>
      <description>几种垃圾回收器： Serial 串行垃圾回收器 为单线程环境设计且只可以使用一个线程进行垃圾回收，会暂停所有用户线程，直到收集结束。所以不适合服务器环境。 Serial 串行收集器是最古老，最稳定已经效率最高的收集器，只使用一个线程去回收，但是其在垃圾回收过程中可能产生较长的停顿（Stop-The-Word 状</description>
    </item>
    
    <item>
      <title>Java GC 1</title>
      <link>https://programya.com/post/Java/JVM/Java-GC-1/</link>
      <pubDate>Fri, 21 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-GC-1/</guid>
      <description>随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低成勋运行的效率，甚至引发系统异常。线程私有部分如程序计数器、虚拟机栈和本地方法栈三个部分随着线程而生，随着线程而灭所以不需要内存回收，垃圾回收的主要部分在堆中。考虑垃圾回收的时候需要思考 3 件事情</description>
    </item>
    
    <item>
      <title>Java 虚拟机内存模型</title>
      <link>https://programya.com/post/Java/JVM/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 17 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>Java 虚拟机运行的时候会把它所管理的内存分划分为若干个不同的数据区域。按照线程之间是否可以共享分为两个部分。线程私有区包含：程序计数器、虚拟机栈、本地方法栈；线程共享区包含：堆、元数据区、直接内存。线程私有区的生命周期和线程相同。 Java 内存模型如下图所示： 线程私有区 程序计数器 程序计数器 是</description>
    </item>
    
    <item>
      <title>Java 逃逸分析</title>
      <link>https://programya.com/post/Java/JVM/Java-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 15 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>当一个对象在方法中被定义后，它可能被外部方法锁引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至可能被外部线程访问到，例如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。逃逸分析的基本行为就是分析对象动态作用区域。 如果分析到一个对象不会逃逸到方法或者线程之外，</description>
    </item>
    
    <item>
      <title>Spring Security</title>
      <link>https://programya.com/post/Spring/Spring-Security/Spring-Security/</link>
      <pubDate>Sat, 15 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Security/Spring-Security/</guid>
      <description>[toc] 权限相关概念 权限管理一般是值根据系统设置的安全规则或者安全策略，用户只能访问被授权的资源。权限管理的前置条件是用户和密码的认证系统。其中认证 是通过用户名和密码成功登陆系统后，让系统得到当前用户的角色身份；授权 则是系统根据当前用户的角色，给其授予可以操作的的权限资源。 主要有三个对</description>
    </item>
    
    <item>
      <title>Java 四种引用类型</title>
      <link>https://programya.com/post/Java/JVM/Java-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 11 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</guid>
      <description>强引用 当内存不足的时候， JVM 开始回收垃圾，对于强引用的对象，就算是出现了 OOM 也不会对该对象进行回收，死都不回收。 强引用是我们常见的普通对象引用，只要还有一个强引用指向一个对象，就表明对象还活着，垃圾收集器不会回收这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用</description>
    </item>
    
    <item>
      <title>Dubbo 原理</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 07 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo-%E5%8E%9F%E7%90%86/</guid>
      <description>参考：Dubbo 开发者指南 Dubbo 整体框架设计如下： 图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。 主要包含 config 层，proxy 服务代理层，registry 注册中心层，cluster 路由层，monitor 监控层，proto</description>
    </item>
    
    <item>
      <title>Java 双亲委派模型</title>
      <link>https://programya.com/post/Java/JVM/Java-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 07 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</guid>
      <description>类加载机制 类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载 -&amp;gt; 验证 -&amp;gt; 准备 -&amp;gt; 解析 -&amp;gt; 初始化 -&amp;gt; 使用 -&amp;gt; 卸载 7个阶段。其中 验证、准备、解析三个阶段可以统称为连接。如图所示： 以上过程中加载、验证、准备、初始化和卸载5个阶段的顺序是确定的，但是解析阶段则不一定，在一些情况下可</description>
    </item>
    
    <item>
      <title>Dubbo 基本配置</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 03 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</guid>
      <description>参考地址：Dubbo 配置 启动时检查 Dubbo 默认情况下在启动的时候会检查依赖的服务是否可用，如果不可用的时候则抛出异常阻止 Spring 初始化的完成。如果是测试或者有循环依赖则需要关闭启动时检查，配置如下： 1 2 3 // # 关闭某个服务的启动时没有提供者的 Check @Reference(check = false) ArticleService articleService; # 关闭所有服务的启动时没有提供者的 Check dubbo.consumer.check=false dubbo.reference.check=false</description>
    </item>
    
    <item>
      <title>Dubbo 基本概念和环境搭建</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 01 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>参考： Dubbo 快速入门 常规的垂直应用架构已无法应对网站应用规模的不断扩大，互联网应用架构大致的演进过程如下： 大致的演进历程也就是： 单一应用架构 -&amp;gt; 垂直应用架构 -&amp;gt; 分布式服务架构 -&amp;gt; 流式计算架构。 在流式计算架构中有一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 Dubbo 是一款高性能Java</description>
    </item>
    
    <item>
      <title>Kubernetes</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/K8S/K8S/</link>
      <pubDate>Sat, 25 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/K8S/K8S/</guid>
      <description>K8S 是一个工业级的容器编排平台。主要有以下一些特点：轻量级，消耗资源少；弹性伸缩；负载均衡。 K8S 是基于 Borg 开发的，Borg 的架构如如下图所示： 首先是 BorgMaster 为了防止单点故障一般情况下都是以集群的形式出现，而且通常应该设置三个以上的奇数个 BorgMaster。Scheduler 调度器，有任务的</description>
    </item>
    
    <item>
      <title>Kafka 使用</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/kafka/Kafka-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 21 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/kafka/Kafka-%E4%BD%BF%E7%94%A8/</guid>
      <description>发送 Kafka 的 Producer 发送消息时采用异步发送的方式，在消息的发送过程中，涉及到了两个线程， main 线程和 sender 线程，以及一个线程共享变量 RecordAccumulator main 线程将消息发送给 RecordAccumulator Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka Broker 上。如下图所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 一个简单的 Producer public class MyPartitionerProducer { static Logger logger = LoggerFactory.getLogger(MyPartitionerProducer.class); public</description>
    </item>
    
    <item>
      <title>Kafka</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/kafka/Kafka/</link>
      <pubDate>Fri, 17 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/kafka/Kafka/</guid>
      <description>kafka 是一个分布式的记于订阅发布模式的消息队列，主要应用于大数据实时处理领域。 消息队列好处：解耦，可恢复性，缓冲，灵活性与峰值处理能力，异步通讯。 消息队列有两种模式：点对点模式即一对一，发布订阅模式即一对多。 Kafka 基础架构 如下图所示： 上图中主要组成有以下几部分： Producer： 消息生产</description>
    </item>
    
    <item>
      <title>Zookeeper 使用</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/Zookeeper-%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 14 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/Zookeeper-%E4%BD%BF%E7%94%A8/</guid>
      <description>Java 连接使用 Zookeeper 的样例 pom 依赖如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.12.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.junit.jupiter&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-jupiter-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.5.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 简单的增加节点/获取节点/判断节点是否存在的操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class MyZookeeper { private static Logger logger = LoggerFactory.getLogger(MyZookeeper.class); private static final String CONNECT_STRING = &amp;#34;192.168.29.128:2181,192.168.29.129:2181,192.168.29.130:2181&amp;#34;; private static final int SESSION_TIMEOUT = 2000; private static ZooKeeper zooKeeper; public static void main(String[] args) throws</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/Zookeeper/</link>
      <pubDate>Tue, 07 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/zookeeper/Zookeeper/</guid>
      <description>Zookeeper 从设计模式角度来看是一个机遇观察者模式的设计的分布式服务管理框架，负责存储和管理需要关心的数据，接受观察者注册，一旦观察的数据状态发生变化，Zookeeper 将负责将通知已经在 Zookeeper 上注册的那些观察者做出相应的反应。Zookeeper 结构图如下： Zookeeper 特点： 一个领导者和多个跟随着组成的</description>
    </item>
    
    <item>
      <title>微服务简介</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 05 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/</guid>
      <description>微服务，通常而言微服务架构是一种架构模式或说是一种架构风格，其倡导将单一应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调相互配合，为用户提供最终价值。服务之间采用轻量级的通讯机制相同通讯。每个服务围绕着具体业务进行构建，并且能够被独立的部署到生产环</description>
    </item>
    
    <item>
      <title>ACID 原则 与 CAP 原则</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/CAP-%E5%8E%9F%E5%88%99-/</link>
      <pubDate>Fri, 03 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/CAP-%E5%8E%9F%E5%88%99-/</guid>
      <description>ACID 原则 A (Atomicity) 原子性 原子性即事务里的所有操作要么全部做完，要么都不做。事务成功的条件就是事务里所有操作都成功，任意一个事务失败，则整个事务就是失败，需要回滚。 C (Consistency) 一致性 一致性即数据库要一直处于一致状态，事务的运行不会改变数据库原本的一致性约束。 I (Isolation) 独立性 独立性即并发的事务之间不会相互</description>
    </item>
    
    <item>
      <title>Docker 入门</title>
      <link>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Docker/</link>
      <pubDate>Wed, 01 Jan 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Docker/</guid>
      <description>基本概念 Docker 镜像是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建多个容器。仓库是存放镜像文件的地方，仓库注册服务器上存放着多个仓库。 镜像可以类比为 Java 的类，而容器可以类比为对象。 Docker 工作原理 Docker 是一个 Client-Server 结构的系统，Docker 守护进程运行在主机上，然后通过 Socket 连接客户端访问，守护</description>
    </item>
    
    <item>
      <title>Rocket MQ</title>
      <link>https://programya.com/post/MQ/RocketMQ/</link>
      <pubDate>Wed, 05 Jun 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/MQ/RocketMQ/</guid>
      <description>RocketMQ 原始文档地址 基本概念 首先 RocketMQ 是由 Producer、Broker、Consumer 三部分组成。其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署中对应一台服务器，每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储在不同的 Broker 上。Me</description>
    </item>
    
    <item>
      <title>Rabbit MQ</title>
      <link>https://programya.com/post/MQ/RabbitMQ/</link>
      <pubDate>Mon, 03 Jun 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/MQ/RabbitMQ/</guid>
      <description>[toc] 概述 多数应用中可以通过消息服务中间件来提升系统异步通信、扩展解耦的能力。其有两个重要的概念：消息代理和目的地。当消息发送者发送消息后，将由消息代理接管，消息代理保证消息传递到指定的目的地。 主要有两种形式： 队列 Queue，点对点通讯。消息发送者发送消息，消息代理将其放入到一个队列</description>
    </item>
    
    <item>
      <title>Active MQ</title>
      <link>https://programya.com/post/MQ/ActiveMQ/</link>
      <pubDate>Sat, 01 Jun 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/MQ/ActiveMQ/</guid>
      <description>面向消息的中间件 是指利用高效可靠的消息机制进行平台的数据交流，并给予数据通信进行分布式系统的集成。通过提供消息传递和消息排列模型在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削风、异步通信、数据同步等功能。简单来说就是解耦，削峰，异步。通用的流程如下： 生产者将消息发送到消息</description>
    </item>
    
    <item>
      <title>Redis 高级</title>
      <link>https://programya.com/post/DataBase/Redis/Redis-%E9%AB%98%E7%BA%A7/</link>
      <pubDate>Mon, 27 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/Redis/Redis-%E9%AB%98%E7%BA%A7/</guid>
      <description>Redis 持久化 RDB Redis DataBase，在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复的时候是将快照文件直接读到内存中。Redis 会单独的创建一个子进程来进行持久化，会先将数据写入到一个临时传文件中，等待持久化过程结束时在用这个临时文件替换上次持久化号的文件。整个过程中主进程是不进行</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://programya.com/post/DataBase/Redis/Redis/</link>
      <pubDate>Sat, 25 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/Redis/Redis/</guid>
      <description>NoSQL NoSQL 即 Not Only Sql, 不仅仅是 SQL。泛指非关系型数据库。 易扩展 NoSQL 数据库种类繁多，共同点都是去掉了关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。 大数据量高性能 NoSQL 数据库都具有非常高的读写性能，主要得益于其无关性，数据库结构简单。 多样灵活的数据模型 NoSQL 无需事先为要存储的数据建立字段</description>
    </item>
    
    <item>
      <title>MySQL 锁及主从复制</title>
      <link>https://programya.com/post/DataBase/MySQL/MySQL-%E9%94%81%E5%8F%8A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Thu, 23 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MySQL/MySQL-%E9%94%81%E5%8F%8A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>锁 从数据操作的类型可以分为读锁和写锁，从对数据操作的粒度分可以分为表锁和行锁。 读写锁 读锁：共享锁针对同一份数据，多个读操作可以同时进行而不会互相影响。 写锁：排它锁，当前写操作没有完成前会阻断其他写锁和读锁。 行表锁 表锁: 偏读，偏向于 MyISAM 存储引擎，开销小，加锁快；锁粒度大，发生锁冲突的</description>
    </item>
    
    <item>
      <title>MySQL 索引及优化</title>
      <link>https://programya.com/post/DataBase/MySQL/MySQL-%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 21 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MySQL/MySQL-%E7%B4%A2%E5%BC%95%E5%8F%8A%E4%BC%98%E5%8C%96/</guid>
      <description>索引 索引是帮助 MySQL 高效获取数据的数据结构，即本质上就是一种数据结构。数据库在存储数据之外还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在数据结构上实现高级的查找算法，一种索引方式如下图所示： 一般来说索引文件本身也很大，所以并不会全部存储在内存中，往往</description>
    </item>
    
    <item>
      <title>MySQL 事务、视图、存储过程及 Join 查询</title>
      <link>https://programya.com/post/DataBase/MySQL/MySQL-%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8F%8A-Join-%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sun, 19 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MySQL/MySQL-%E4%BA%8B%E5%8A%A1%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8F%8A-Join-%E6%9F%A5%E8%AF%A2/</guid>
      <description>事务 对于 MySQL 中只有使用 Innodb 数据库搜索引擎的数据卷或表才支持事务，事务是用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。用来管理 insert, update, delete 语句，一般来说事务需要满足 4 个条件 ACID，即原子性 A，一致性 C，隔离性 I，持久性 D。 原子性：一个事务的所有操作要么全部完成，要么</description>
    </item>
    
    <item>
      <title>MySQL 查询优化</title>
      <link>https://programya.com/post/DataBase/MySQL/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 17 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MySQL/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid>
      <description>架构 MySQL 架构图如下： 连接层 最上层是一些客户端和连接服务，包含本地 Socket 通信和大多数基于客户端/服务端工具实现的类似 TCP/IP 的通讯。主要完成一些类似于连接处理、授权认证及相关安全的方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层是基于 SSL 的安全连接。服务器也会为安</description>
    </item>
    
    <item>
      <title>MyBatis SQL 映射</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBatis-SQL-%E6%98%A0%E5%B0%84/</link>
      <pubDate>Wed, 15 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBatis-SQL-%E6%98%A0%E5%B0%84/</guid>
      <description>一个包含增删改查的 MyBatis Mapper 文件如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE mapper PUBLIC &amp;#34;-//mybatis.org//DTD Mapper 3.0//EN&amp;#34; &amp;#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;#34;&amp;gt; &amp;lt;mapper namespace=&amp;#34;com.xinyue.imybatis.mapper.UserMapper&amp;#34;&amp;gt; &amp;lt;select id=&amp;#34;getUserById&amp;#34; resultType=&amp;#34;User&amp;#34; databaseId=&amp;#34;mysql&amp;#34;&amp;gt; select id, name, password, first_name firstName, last_name lastName from user where id = #{id} &amp;lt;/select&amp;gt; &amp;lt;insert id=&amp;#34;createUser&amp;#34; parameterType=&amp;#34;User&amp;#34;&amp;gt; insert into user (name, password, first_name, last_name) values (#{name}, #{password}, #{firstName}, #{lastName}) &amp;lt;/insert&amp;gt; &amp;lt;update id=&amp;#34;updateUser&amp;#34;&amp;gt; update user set name = #{name}, password=#{password}, first_name=#{firstName} where id=#{id} &amp;lt;/update&amp;gt; &amp;lt;delete id=&amp;#34;deleteUser&amp;#34;&amp;gt; delete from user where id = #{id} &amp;lt;/delete&amp;gt; &amp;lt;/mapper&amp;gt; 一个简单的测试样例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void testCreate() { try {</description>
    </item>
    
    <item>
      <title>MyBatis 自定义 TypeHandler</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBaits-%E8%87%AA%E5%AE%9A%E4%B9%89-TypeHandler/</link>
      <pubDate>Mon, 13 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBaits-%E8%87%AA%E5%AE%9A%E4%B9%89-TypeHandler/</guid>
      <description>MyBaits 支持通过自定义的 TypeHandler 的形式来设置参数或从结果中取出数据集的时候的封装策略。主要有以下几步： 实现 TypeHanlder结果或者继承 BaseTypeHandler 使用 @MappedTypes 定义处理的 Java 类型，使用 @MapJdbcTypes 定义 jdbc type 类型 在参数处理或自定义结果集处理的时候标明使用自定义的 TypeHandler 处理。也可以在全局配置 TypeHandler 要处理的 javaType 定义一个枚举类放到 User 上</description>
    </item>
    
    <item>
      <title>MyBatis 运行原理</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBaits-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 11 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBaits-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</guid>
      <description>MyBaits 分层结构图 MyBatis 过程整个过程有以下四步： 创建 SqlSessionFactory 获取 SqlSession 获取代理对象 执行方法 获取 SqlSessionFactory 1 2 3 4 5 6 public SqlSessionFactory getSqlSessionFactory() throws IOException { // 获取配置的文件流 InputStream inputStream = Resources.getResourceAsStream(&amp;#34;mybatis-config.xml&amp;#34;); // 根据配置使用 SqlSessionFactoryBuilder 生成 SqlSessionFactory return new SqlSessionFactoryBuilder().build(inputStream); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SqlSessionFactoryBuilder public SqlSessionFactory build(InputStream inputStream) { // 调用内部的 build 方法 return build(inputStream, null, null); } public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { // 根据配置</description>
    </item>
    
    <item>
      <title>MyBatis 配置文件</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBaits-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBaits-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>MyBaits 是一个半自动化的持久化层框架，支持定制化 SQL，存储过程以及高级映射。避免 JDBC 代码和手动设置参数以及获取结果集。其使用简单的 XML 或注解用于配置和原始映射，将接口和 Java 的对象映射成数据库记录。 一个简单的项目配置如下： pom.xml 配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &amp;lt;dependencies&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.3&amp;lt;/version&amp;gt;</description>
    </item>
    
    <item>
      <title>MyBatis 缓存</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBaits-%E7%BC%93%E5%AD%98/</link>
      <pubDate>Tue, 07 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBaits-%E7%BC%93%E5%AD%98/</guid>
      <description>MyBatis 具有非常强大的缓存特性，可以方便的配置和定制。其默认定义了两级缓存：分布是一集缓存和二级缓存。 一级缓存：又称本地缓存。作用域为 sqlSession, 当 Session flush 或 close 之后，该 Session 中的所有 Cache 将被清空。其默认情况一级缓存开启，而且不能关闭，不过可以通过调用 clearCache 来清空本地缓存可以通过设置 localCacheScope 来修改缓存的作用域，有 SESSION |</description>
    </item>
    
    <item>
      <title>MyBatis 动态 SQL</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBaits-%E5%8A%A8%E6%80%81-SQL/</link>
      <pubDate>Sun, 05 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBaits-%E5%8A%A8%E6%80%81-SQL/</guid>
      <description>使用 MyBatis 可以很轻松的完成动态 SQL 的拼写。 一个简单的使用 if 拼接的查询方法如下： 1 2 3 4 5 6 7 8 9 &amp;lt;!-- List&amp;lt;User&amp;gt; queryUser(@Param(&amp;#34;id&amp;#34;) Integer id, @Param(&amp;#34;name&amp;#34;) String name, @Param(&amp;#34;firstName&amp;#34;) String firstName, @Param(&amp;#34;lastName&amp;#34;) String lastName); --&amp;gt; &amp;lt;select id=&amp;#34;queryUser&amp;#34; resultType=&amp;#34;User&amp;#34; databaseId=&amp;#34;mysql&amp;#34;&amp;gt; select * from user where 1 = 1 &amp;lt;if test=&amp;#34;id != null&amp;#34;&amp;gt;and id = #{id} &amp;lt;/if&amp;gt; &amp;lt;if test=&amp;#34;name != null and name.trim() != &amp;#39;&amp;#39;&amp;#34;&amp;gt;and name = #{name} &amp;lt;/if&amp;gt; &amp;lt;if test=&amp;#34;firstName != null and firstName != &amp;#39;&amp;#39;&amp;#34;&amp;gt;and first_name = #{firstName} &amp;lt;/if&amp;gt; &amp;lt;if test=&amp;#34;lastName != null and lastName != &amp;#39;&amp;#39;&amp;#34;&amp;gt;and last_name = #{lastName} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt; 当然也可以使用 where 标签去省略掉 where 关键字： 1 2 3 4</description>
    </item>
    
    <item>
      <title>MyBaits 插件</title>
      <link>https://programya.com/post/DataBase/MyBatis/MyBaits-%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Fri, 03 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/DataBase/MyBatis/MyBaits-%E6%8F%92%E4%BB%B6/</guid>
      <description>MyBatis 在创建四个主要对象（Executor， ParameterHandler, ResultSetHandler, StatementHandler）的过程中都会使用到插件。插件可以利用动态代理机制一层层的包装目标对象从而实现在目标对象执行目标方法之前进行拦截。 一个简单的插件编写如下： 首先编写实现 Interceptor 的主类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description>
    </item>
    
    <item>
      <title>Tmux</title>
      <link>https://programya.com/post/Others/Tmux/</link>
      <pubDate>Wed, 01 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Tmux/</guid>
      <description>Tmux 是一个终端复用器类自由软件，用户可以通过 tmux 在一个终端内管理多个分离的会话，窗口及面板，对于同时使用多个命令行，或多个任务时非常方便。 tmux 主要由以下几个模块组成： server 服务，tmux 运行的基础服务，以下的模块均依赖此服务 session 会话，一个服务可以包含多个会话 window 窗口，一个会话可以包含多个窗口 panel</description>
    </item>
    
    <item>
      <title>Cookie 和 Session</title>
      <link>https://programya.com/post/Others/Session-%E5%92%8C-Cookie/</link>
      <pubDate>Thu, 25 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Session-%E5%92%8C-Cookie/</guid>
      <description>Cookie 和 Session Cookie Cookie 的作用 Cookie的作用像是去超市购物的时候办理的购物卡，里面村上了你的个人信息，下次来到超时后的时候，超市可以识别你的会员卡，直接购物。 由于 HTTP 是一种无状态协议，当用户的一次访问请求结束后，后端服务器无法知道下一次来访问的是否还是上次访问的用户。Cookie 的作用就是用</description>
    </item>
    
    <item>
      <title>Maven 入门</title>
      <link>https://programya.com/post/Others/Maven/</link>
      <pubDate>Tue, 23 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Maven/</guid>
      <description>构建的各个环节 清理：将以前编译得到的旧的 class 字节码文件删除，为下一次编译做准备 编译：将 Java 源程序编译成 class 字节码文件 测试：自动测试，自动调用 junit 程序 报告：测试程序执行的结果 打包：动态 Web工程打 war 包，Java 工程打 jar 包 安装：将打包得到的文件复制到 ”仓库“ 中指定的位置 部署：将打包后的文件部</description>
    </item>
    
    <item>
      <title>Linux 命令</title>
      <link>https://programya.com/post/Others/Linux-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 21 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Linux-%E5%91%BD%E4%BB%A4/</guid>
      <description>强制卸载软件： 1 2 3 4 sudo mv /var/lib/dpkg/info/{packagename}.* /tmp/ sudo dpkg --remove --force-remove-reinstreq {packagename} sudo apt-get remove {packagename} sudo apt-get autoremove &amp;amp;&amp;amp; sudo apt-get autoclean 常用命令： top 命令： load average: 三个值分别是系统 1分钟，5分钟，15分钟系统的负载平均值。如果三个值相加，除以3，乘以 100%的结果大于 60%，则表明系统压力过大。 uptime 命令精简版，显示系统负载情况。 vmstat 命令； vmstat -n 2 3 每 2 秒查询一次，</description>
    </item>
    
    <item>
      <title>Jenkins 自动部署</title>
      <link>https://programya.com/post/Others/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Fri, 19 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Jenkins-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</guid>
      <description>博客后台每次 build 之后都需手动放到服务器上，然后停掉原本的服务，重新启动服务。为了简化流程所以使用 Jenkins 进行自动化部署。 首先项目是基于 Docker 的（至于 Jenkins 和 Docker 的安装非常流程化，这边不赘述）。 将项目打包成 Docker 镜像 首先编写 Dockerfile 简单如下， 1 2 3 4 5 6 FROMopenjdk:11.0-jre-slimMAINTAINERxinyue&amp;lt;xinyue@xinyue.com&amp;gt;EXPOSE8081VOLUME/tmpADD /target/blog-0.0.1-SNAPSHOT.jar app.jarENTRYPOINT [ &amp;#34;java&amp;#34;, &amp;#34;-jar&amp;#34;, &amp;#34;/app.jar&amp;#34;, &amp;#34;--spring.profiles.active=prd&amp;#34;] 对于我的项目非常的简单，就是基于 openjdk 11 的镜</description>
    </item>
    
    <item>
      <title>Debug Java 程序 对象后面的数字是什么</title>
      <link>https://programya.com/post/Others/Java-%E7%A8%8B%E5%BA%8F-Debug-%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 17 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Java-%E7%A8%8B%E5%BA%8F-Debug-%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>在 Debug Java 程序的时候，在 IDEA 的 Variables 窗口中经常可以看到类似下图形式的变量： {ConcurrentHashMap$Segment@873} 中的 873 是 JVM 在调试的时候提供的唯一的 ObjectId，在程序内部是无法访问的。可以参考 Stack Overflow上的一个问答： Deciphering variable information while debugging Java 后半部分：java.util.concurrent.ConcurrentHashMap</description>
    </item>
    
    <item>
      <title>Git Action 自动部署</title>
      <link>https://programya.com/post/Others/Github-Action-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 15 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Github-Action-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</guid>
      <description>博客的前端项目同样需要在每次修改之后自动部署到服务器上，但是由于服务器内存太小导致，运行 npm run build 命令的时候内存不足导致其他程序异常退出，所以没有使用 Jenkins 进行自动化部署。然后发现 Github 提供了 Action 可以进行自动化 build 部署。所以对于前端项目使用 GitHub Action 进行部署。 本文仅记录自己前端项目的自动构建配置流程，</description>
    </item>
    
    <item>
      <title>Git 基础</title>
      <link>https://programya.com/post/Others/Git-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 13 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Git-%E5%9F%BA%E7%A1%80/</guid>
      <description>Git 是一个开源的分布式版本控制系统，Git 主要分为三个区域：工作区，暂存区和版本库 上图中左侧为工作区域，右侧为版本库。在版本库中标记为 index 的区域是暂存区，标记 master 的是代表 master 分支锁代表的目录树。 Git 常用命令 Git 配置命令 1 2 3 git config --list 列出所有的配置信息 git config --global user.name &amp;#34;User Name&amp;#34; git config --global user.email &amp;#34;User Email&amp;#34; Git 基本命令 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>Nginx Root</title>
      <link>https://programya.com/post/Others/Nginx/Nginx-Root/</link>
      <pubDate>Thu, 11 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Nginx/Nginx-Root/</guid>
      <description>proxy_pass proxy_pass 一般有四种设置方式, 例如访问 index.html 页面： 1 代理 URL： http://127.0.0.1/index.html 1 2 3 location /proxy/ { proxy_pass http://127.0.0.1/; } 2 代理 URL： http://127.0.0.1/proxy/index.html 1 2 3 location /proxy/ { proxy_pass http://127.0.0.1; } 3 代理 URL：http://127.0.0.1/demo/index.html 1 2 3 location /proxy/ { proxy_pass http://127.0.0.1/demo/; } 4 代理 URL：http://127.0.0.1/proxy/demo/ind</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://programya.com/post/Others/Nginx/Nginx/</link>
      <pubDate>Tue, 09 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Nginx/Nginx/</guid>
      <description>Nginx 是一个高性能的 HTTP 和反向代理服务器，占用内存少，并发能力强，可以作为静态页面的 Web 服务器，同时支持 CGI 协议的动态语言，例如 perl、php 等。但是不支持 Java，Java 程序只能通过 Tomcat 的配合完成。Nginx 专为性能优化开发，性能是其最重要的考量，非常注重效率，能够经受住高负载的考研。</description>
    </item>
    
    <item>
      <title>Netty Java IO 模型</title>
      <link>https://programya.com/post/Others/Netty/Netty-Java-IO-%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 07 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-Java-IO-%E6%A8%A1%E5%9E%8B/</guid>
      <description>Java 模型简单的理解就是使用什么样的通道惊醒数据的发送和接收，这很大程度上决定了程序通讯的性能。Java 支持 3 种网络编程模型 IO：BIO，NIO，AIO。 BIO 是同步阻塞模型，服务器实现模式为一个连接对应一个线程，即客户端有请求的时候服务端就需要启动一个线程进行处理，如果这个连接不作任何</description>
    </item>
    
    <item>
      <title>Netty EventLoop</title>
      <link>https://programya.com/post/Others/Netty/Netty-EventLoop/</link>
      <pubDate>Fri, 05 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-EventLoop/</guid>
      <description>NioEventLoop 的继承关系图如下： 首先看一下 SingleThreadEventLoop 类的 execute 方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public void execute(Runnable task) { ObjectUtil.checkNotNull(task, &amp;#34;task&amp;#34;); execute(task, !(task instanceof LazyRunnable) &amp;amp;&amp;amp; wakesUpForTask(task)); } private void execute(Runnable task, boolean immediate) { boolean inEventLoop = inEventLoop(); // 将 task 添加到队列中 addTask(task); if (!inEventLoop) { // 如果该 EventLoop 线程不是当前线程则尝试启动线程 startThread(); if (isShutdown()) { boolean reject = false; try { // 如果启动失败，从 task 队列中移除</description>
    </item>
    
    <item>
      <title>Netty 主要组件</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 03 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6/</guid>
      <description>Netty 的主要组件有 Channel， EventLoop，ChannelFuture，ChannelHandler，ChannelPipeline 等。 ChannelHandler 其中 ChannelHandler 是处理出入站数据的业务逻辑容器。例如通过实现 ChannelInboundHandler 接口，就可以接收入站事件和数据。当要给客户端端发送响应的时候，也可以从 ChannelInboundHandler 中写数据。业</description>
    </item>
    
    <item>
      <title>Netty 心跳机制</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</guid>
      <description>Netty 提供了一个重要的服务心跳机制 heartbeat。通过心跳检查对方是否有效，这是 RPC 框架中必不可少的功能。接下来分析相关源码的实现。 Netty 提供了 IdleStateHandler, ReadTimeoutHandler, WriteTimeoutHandler 三个 Handler 检测连接的有效性。 IdleStateHandler：当连接的空闲时间（读/写）太长时，将会触发一个 IdleStateEvent 事件，然后可以通过 ChannelInboundHandler 中重写 userEventTrigged 方</description>
    </item>
    
    <item>
      <title>Netty 异步线程池</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Wed, 27 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 Netty 对 Socket 的处理速度。解决方案则是将任务添加到异步线程池中，主要有两种方式： handler 中加入线程池 context 中加入线程池 Handler 中加入线程池 在 Handler 中添加一个 EventExecutorGroup，需要创建线程的时候使用 group.submit 创建线程，整个流程则变成如</description>
    </item>
    
    <item>
      <title>Netty 三大组件</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 25 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</guid>
      <description>ChannelPipeline, ChannelHandler 和 ChannelHandlerContext 三者的关系是每当 ServerSocket 创建一个新的连接，就会创建一个 Socket 对应的就是目标客户端。每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline。每个 ChannelPipeline 包含多个 ChannelHandlerContext，其是一个双向链表，包装了通过 addLast 方法添加的 ChannelHandler。 ChannelSocket 和</description>
    </item>
    
    <item>
      <title>Netty 入门</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 23 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E5%85%A5%E9%97%A8/</guid>
      <description>Netty 是由 JBOSS 提供的一个 Java 开源框架，现在是 GitHub 上的独立项目。其是一个异步的，基于事件驱动的网络应用框架，也来快速开发高性能，高可用的网络 IO 程序。主要针对在 TCP 协议下，面向 Clients 端的高并发应用，或者在 P2P 场景下的大量数据持续传输的应用。本质上还是一个 NIO 框架，适用于服务器通讯相关的多种应用场景。 在分</description>
    </item>
    
    <item>
      <title>Netty 源码</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E5%90%AF%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%BA%90%E7%A0%81/</link>
      <pubDate>Thu, 21 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E5%90%AF%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%BA%90%E7%A0%81/</guid>
      <description>一个 Server 端的 Sample Code 如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public final class EchoServer { static final boolean SSL = System.getProperty(&amp;#34;ssl&amp;#34;) != null; static final int PORT = Integer.parseInt(System.getProperty(&amp;#34;port&amp;#34;, &amp;#34;8007&amp;#34;)); public static void main(String[] args) throws Exception { // 配置 SSL 的信息 final SslContext sslCtx; if (SSL) { SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); } else { sslCtx = null; } // 配置 Server 的信息 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); final EchoServerHandler serverHandler = new EchoServerHandler();</description>
    </item>
    
    <item>
      <title>Netty 核心</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E6%A0%B8%E5%BF%83/</link>
      <pubDate>Tue, 19 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E6%A0%B8%E5%BF%83/</guid>
      <description>Bootstrap 和 ServerBootstrap Bootstrap 即导引，一个 Netty 应用通常由一个 Boostrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中的 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。常用方法如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 服务端用来设置两个 Event Group public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup); // 客户端用来设置一个</description>
    </item>
    
    <item>
      <title>Netty 线程模型</title>
      <link>https://programya.com/post/Others/Netty/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 17 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Others/Netty/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid>
      <description>目前主要存在两种线程模型：传统阻塞 IO 服务模型和 Reactor 模式。其中 Reactor 模式根据处理资源池线程的数量不同有三种典型的实现： 单 Reactor 单线程 单 Reactor 多线程 主从 Reactor 多线程 Netty 是根据主从 Reactor 多线程模型做了一点的改进，其中的主从Reactor 多线程模型有多个 Reactor。 传统阻塞 IO 服务模型 黄色表示对象，蓝色表示线</description>
    </item>
    
    <item>
      <title>Spring Cloud Eureka</title>
      <link>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Fri, 15 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description>Eureka 是 Netflix 的一个子模块，也是核心模块之一。Eureka 是一个基于 REST 的服务，用于定位服务，实现云端中间层服务发现与故障转移。服务注册与发现对于微服务是非常的重要的，有了服务注册与发现只需要使用服务的标识符，就昆虫访问到服务，而不需要修改服务调用的配置文件。功能和 Dubbo 的注册中心类似。Eur</description>
    </item>
    
    <item>
      <title>Spring Cloud Ribbon Feign Hystrix Zuul</title>
      <link>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Wed, 13 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>Ribbon Spring Cloud Ribbon 是基于 Netflix Ribbon 实现一套客户端负载均衡的工具。Ribbon 是 Netflix 发布的开源项目，其主要功能是提供客户端的负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 客户端组件提供了一系列完善的配置项如连接超时，重试等。简单的说就是在配置文件中列出 Load Balancer 后面所有的服务，Ribbon 会自动的</description>
    </item>
    
    <item>
      <title>Spring Cloud Config Server</title>
      <link>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-ConfigServer/</link>
      <pubDate>Mon, 11 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-ConfigServer/</guid>
      <description>微服务意味着将单体应用的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式，动态的配置管理是必要的。Spring Cloud 提供了 Config Server 来解决这个问题，其为微服务架构中的微服务提供集中化的外部配置支持，配置服务</description>
    </item>
    
    <item>
      <title>Spring Boot MyBatis 多数据源配置</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-MyBatis-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 09 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-MyBatis-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</guid>
      <description>主要有两种配置方式：第一种是自定义配置 SqlSessionFactory ，第二种是使用 AbstractRoutingDataSource + AOP 的方式实现 自定义 SqlSessionFactory 首先关闭 Spring Boot 对于 DataSourceAutoConfiguration: 1 2 3 @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class }) 然后配置 DataSourceConfig，例如这边有两个数据库连接： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class DataSourceConfig { @Bean(name = &amp;#34;db1&amp;#34;) @ConfigurationProperties(prefix = &amp;#34;spring.datasource.db1&amp;#34;) public DataSource db1Source() { return DataSourceBuilder.create().build(); } @Bean(name = &amp;#34;db2&amp;#34;) @ConfigurationProperties(prefix = &amp;#34;spring.datasource.db2&amp;#34;) public DataSource db2Source() { return DataSourceBuilder.create().build(); } } 然后在配</description>
    </item>
    
    <item>
      <title>Java OOM</title>
      <link>https://programya.com/post/Java/JVM/Java-OOM/</link>
      <pubDate>Thu, 07 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JVM/Java-OOM/</guid>
      <description>StackOverflowError 1 2 3 4 5 6 7 8 9 public class StackOverFlowErrorDemo { public static void main(String[] args) { stackOverFlow(); } private static void stackOverFlow() { stackOverFlow(); } } 递归调用过多，导致溢出。 1 2 3 4 5 6 7 8 9 10 11 12 Exception in thread &amp;#34;main&amp;#34; java.lang.StackOverflowError at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) at demo.oom.StackOverFlowErrorDemo.stackOverFlow(StackOverFlowErrorDemo.java:13) OutOfMemoryError: Java heap space 1 2 3 4 5 6 7 8 9 public class JavaHeapSpaceDemo { public static void main(String[] args) { String string = &amp;#34;demo&amp;#34;; while (true) { string += string + new Random().nextInt(100000000); string.intern(); } } } 内存不足导致，堆内存溢出 1 2 3 4 5 6 Exception</description>
    </item>
    
    <item>
      <title>Spring Boot Actuator</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-Actuator/</link>
      <pubDate>Thu, 07 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-Actuator/</guid>
      <description>通过引入 spring-boot-starter-actuator 可以使用 Spring Boot 为我们提供的应用的监控和管理功能。可以通过 HTTP，JMX，SSH 协议进行操作，自动得到审计、健康及指标信息。pom 文件中设置如下： 1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 主要有以下一些内容： /actuator 启用了哪些 actuator /actuator/beans 容器中每个组件的定义信息 /actuator/caches 容器中的 Cache 信息 /actuator/caches/{cache} 容器中具体 Cache 的缓存条目 /actuator/health/{*path} 和 /actuator/health 应用</description>
    </item>
    
    <item>
      <title>Spring Boot 自动配置</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 05 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>众所周知 Spring Boot 极大的减少了 Spring 繁琐的配置，采用约定大于配置的策略。也是基于此 Spring Boot 有很多自动配置的逻辑，下面简单理一下相关的代码。 首先对于 Spring Boot 应用主启动类上要标注 @SpringBootApplication 如下所示，那么这个注解为会 Spring Boot 添加哪些配置的呢？下面可以看一下相关的源码。 1 2 3 4 5 6 @SpringBootApplication public class MyMainApplication { public static void main(String[] args) { SpringApplication.run(MyMainApplication.class); } } 引入如下</description>
    </item>
    
    <item>
      <title>Spring Boot 自定义 Starter</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89-Starter/</link>
      <pubDate>Sun, 03 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89-Starter/</guid>
      <description>Starter 只是用来引入自动配置模块，Starter 依赖自动配置，其他人使用的时候只需要引入 Starter 即可。另外对于我们自己实现的 Starter 推荐命名是 xxx-spring-boot-starter。 首先创建一个空项目例如 mystarter, 打开项目创建两个 Module，一个是普通的 Maven 项目，一个是 Spring Boot 项目。如下图所示： 对于 Starter</description>
    </item>
    
    <item>
      <title>Spring Boot 使用外部容器</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8-Servlet-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 01 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8-Servlet-%E5%AE%B9%E5%99%A8/</guid>
      <description>基本项目创建 在创建项目的时候使用 war 的方式打包： 其实主要的 pom 文件的配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;webwar&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;!--打包方式设置为 war--&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;!--将内置的 Tomcat 设置为 provided --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 在主目录下编写 SpringBootServletInitializer 的子类并实现其 configure 方法，样例如下： 1 2 3 4 5 6 7 public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { // 将 主类作为参</description>
    </item>
    
    <item>
      <title>Spring Boot 日志</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 25 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>开发用到的框架大概有：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j&amp;hellip;.。其中 JCL， SLF4J， Jboss-logging 是日志门面，log4j, jul, log4j, Logback 是日志的实现. Spring Boot 选用的是 SLF4J 和 Logback 的实现。依赖如下： 在自己的系统中使用 slf4j 的话首先要导入 slf4j</description>
    </item>
    
    <item>
      <title>Spring Boot 嵌入式容器</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 23 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>对于嵌入式容器的配置 Spring 的基本的 Server 的配置都可以在 application.yaml 中通过 server 相关的属性进行配置。 其对应的配置类是 1 2 3 4 5 6 7 8 9 10 11 @ConfigurationProperties(prefix = &amp;#34;server&amp;#34;, ignoreUnknownFields = true) public class ServerProperties { private final Tomcat tomcat = new Tomcat(); public static class Tomcat { private final Accesslog accesslog = new Accesslog(); private String protocolHeader; private String protocolHeaderHttpsValue = &amp;#34;https&amp;#34;; private String portHeader = &amp;#34;X-Forwarded-Port&amp;#34;; } } 其内部类 Tomcat 用户配置 Tomcat 相关的信息。在 ServletWebServerFactoryCustomizer 会使用 其中的配置对 嵌入式容器进行配置， 同样</description>
    </item>
    
    <item>
      <title>Spring Boot 缓存</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E7%BC%93%E5%AD%98/</link>
      <pubDate>Thu, 21 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E7%BC%93%E5%AD%98/</guid>
      <description>JSR 107 首先 JSR 107 即 JCache API的首个早期草案，在 Java JCache 中定义了 5 个核心内容，即 CachingProvider，CacheMaager，Cache，Entry 和 Expiry。 CachingProvider 中定义了创建、配置、获取、管理和控制多个 CacheManager, 一个应用可以在运行期间访问多个 CahingProvider。 CacheManger 定义了创建、</description>
    </item>
    
    <item>
      <title>Spring Boot 配置文件</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 19 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>Spring Boot 默认使用 properties 文件来配置属性，也可以使用 YAML 文件进行配置。YAML 以数据为中心，比 json 和 xml 等更适合做配置文件。 基本语法 K:[空格]V 表示一对键值对。以空格的缩进控制层级关系, 属性和值均是大小写敏感的，只要是左对齐的一列数据，都是同一个层级的。 1 2 server:port:8080 普通值 数字 字符串 布尔 字符串默认不用加</description>
    </item>
    
    <item>
      <title>Spring Boot 错误处理机制</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 17 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</guid>
      <description>Spring 针对于浏览器访问和客户端访问使用不同的处理逻辑。如果是浏览器则返回一个出错的网页，而如果是客户端则返回 JSON 格式的错误数据。其处理的原理如下： 在 ErrorMvcAutoConfiguration 有对于出错处理的自动配置。其为容器中添加了 DefaultErrorAttributes Bean 在页面中共享信息。 1 2 3 4 5 @Bean @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); } 此外为容器中添加了 BasicErrorController Bean，处</description>
    </item>
    
    <item>
      <title>Spring Security 入门</title>
      <link>https://programya.com/post/Spring/Spring-Security/Spring-Security-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 15 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Security/Spring-Security-%E5%85%A5%E9%97%A8/</guid>
      <description>Spring Security 就是通过一条过滤器链使用认证和授权的工作。如下图所示： 其中 FilterSecurityInterceptor 中会根据 config 配置的内容，判断是否可以访问对应的资源，如果不可以则会抛出异常。然后在 ExceptionTranslationFilter 中会捕获异常并作出响应的处理。 Spring Security 几个重要的概念如下： SecurityContextHolder Spring Security 提供的 SecurityContextHolder 类让程序可以方便访问 SecurityContext。其采用的是 ThreadLocal 方</description>
    </item>
    
    <item>
      <title>Spring MVC Web 组件</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Web-%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 13 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Web-%E7%BB%84%E4%BB%B6/</guid>
      <description>Web 主要有三个组件，分别是 servlet, filter, listener. Servlet 其主要作用是处理客户端请求的动态资源。Servlet 通常需要接受请求，处理请求，完成响应。其生命周期分为四个阶段，1 调用构造方法实例化，2 调用 init 方法初始化，3 处理请求调用 Service 方法，4 服务终止 调用 destory 方法。在 web.xml 配置一个简单的 Servlet 如下： 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    
    <item>
      <title>Spring MVC Model And View</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Model-And-View/</link>
      <pubDate>Mon, 11 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Model-And-View/</guid>
      <description>Spring MVC 在 ModelAndView 上添加数据主要以下三个方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public ModelAndView addObject(Object attributeValue) { // 调用添加数据的方法 getModelMap().addAttribute(attributeValue); return this; } public ModelMap addAttribute(Object attributeValue) { Assert.notNull(attributeValue, &amp;#34;Model object must not be null&amp;#34;); // 如果为空则直接返回 if (attributeValue instanceof Collection &amp;amp;&amp;amp; ((Collection&amp;lt;?&amp;gt;) attributeValue).isEmpty()) { return this; } // 根据数据类型获取类名作为参数名称 return addAttribute(Conventions.getVariableName(attributeValue), attributeValue); } public ModelMap addAttribute(String attributeName, @Nullable Object attributeValue) { Assert.notNull(attributeName, &amp;#34;Model attribute name</description>
    </item>
    
    <item>
      <title>Spring MVC 自定义拦截器</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Sat, 09 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>Spring MVC 也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现 HandlerInterceptor 接口，其主要有三个方法： preHandle() 这个方法再业务处理请求之前被调用，在该方法中对用户请求 request 进行处理，如果需要该拦截器对请求进行拦截处理后还要调用其他拦截器或者业务方法进行处理则返回 tru</description>
    </item>
    
    <item>
      <title>Spring MVC @RequestMapping 注解</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Thu, 07 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E6%B3%A8%E8%A7%A3/</guid>
      <description>SpringMVC 使用 @RequestMapping 注解为控制器指定可以处理哪些 URL 请求，在 Controller 的类和方法上都可以使用该注解，标记在类上提供初步的请求映射信息，相对于 Web 应用的根目录。标记在方法上提供进一步细分映射信息，对于标记在类上的 URL，如果方法所在的类未标注则 URL 是相对于 Web 应用的根目录。在 DispatcherServlet 截获请求后，就通过 @RequestMapping 提供的映射信</description>
    </item>
    
    <item>
      <title>Spring MVC 运行流程</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 05 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>调用的起点是 org.springframework.web.servlet.DispatcherServlet#doService 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // DispatcherServlet protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) { attributesSnapshot = new HashMap&amp;lt;&amp;gt;(); Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) { String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) { attributesSnapshot.put(attrName, request.getAttribute(attrName)); } } } // Make framework objects available to handlers and view objects. // 在 request</description>
    </item>
    
    <item>
      <title>Spring MVC 异步处理</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 03 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</guid>
      <description>在 Servlet 3.0 的时候增加了对异步的支持，在此之前 Servlet 采用 Thread Per Request 的方式处理请求。即如果一个请求如果进行耗时的操作例如 IO，数据库或者调用第三方的接口等等，其所对应的的线程将同步的等待响应操作的完成，所以此时线程并不能即使的释放线程放回线程池以供后续使用，在并发量大的情况下，这会带来性能问题。</description>
    </item>
    
    <item>
      <title>Spring 和 Spring MVC 整合</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-%E5%92%8C-Spring-MVC%E6%95%B4%E5%90%88/</link>
      <pubDate>Fri, 01 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-%E5%92%8C-Spring-MVC%E6%95%B4%E5%90%88/</guid>
      <description>Web 容器启动的时候会扫描每个 jar 包下的 META-INF\services\javax.servlet.ServletContainerInitializer 文件中的内容，根据文件中的定义全类名找到 ServletContainerInitializer 的子类，然后调用其 onStartup 方法。在引入的 spring-web 下就有这样的一个文件，其内容是 org.springframework.web.SpringServletContainerInitializer， 即定义了一个 Spri</description>
    </item>
    
    <item>
      <title>Spring Data</title>
      <link>https://programya.com/post/Spring/Spring-Data/Spring-Data/</link>
      <pubDate>Mon, 28 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/Spring-Data/</guid>
      <description>Spring Data 用于简化数据库访问，能够减少数据访问层的开发量，只需要声明持久层接口，其他都由 Spring Data JPA 完成。支持 NoSQL 和 关系数据存储，主要目的是使数据库的访问变得更加便捷。支持的 NoSQL 有 MongoDB， Neo4j, Redis 和 Hbase，支持数据库存储技术有 JDBC 和 JPA。 Repository 是一个空接口即标记接口，如果定义的接口继承了 Repository 则</description>
    </item>
    
    <item>
      <title>JPA JPQL</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPQL/</link>
      <pubDate>Sun, 27 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPQL/</guid>
      <description>JPQL 语言，即 Java Persistence Query Language 是一种和 SQL 非常相似的中间性和对象查询语言，其最终会被编译成针对于不同底层数据库的 SQL 查询，从而屏蔽掉不同数据库的差异。JPQL 的语句都是通过 Query 接口封装执行的。 Query 接口主要有以下几个方法： int executeUpdate(); 执行 Update 或者 Delete 语句。 List getResultList(); 执行 Select 语句并返回结果实体列表。 Object getSingleResult(); 用于执行只返回单个结</description>
    </item>
    
    <item>
      <title>JPA 映射关系</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPA-%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sat, 26 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPA-%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</guid>
      <description>对于一对多的情况使用一个 Department 类和一个 Student 类。 单向多对一 在多的一端（Student）维护数据，则需要在多的一端设置如下的注解： 1 2 3 4 5 6 7 8 9 10 11 12 private Department department; // 设置多对一，且设置懒加载 @ManyToOne(fetch = FetchType.LAZY) // 设置 Mapping 列的名称 @JoinColumn(name = &amp;#34;department_id&amp;#34;) public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } 在插入的时候最好先插入一的一端，再插入多的一</description>
    </item>
    
    <item>
      <title>JPA 基本注解</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPA-%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 25 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPA-%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3/</guid>
      <description>JDBC 是 Sun公司提供了一套访问数据库的接口规范，数据库厂商必须遵守Sun公司的规范，提供访问自己数据库服务器API即驱动；JDBC只是一些接口，需要数据库厂商提供相应的实现类即驱动，如果没有驱动无法连接数据库，更无法操作数据库。 JPA 即 Java Persistence API，用于对象持久化的 API 是一个规范，Java</description>
    </item>
    
    <item>
      <title>JPA EntityManager</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPA-EntityManager/</link>
      <pubDate>Thu, 24 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPA-EntityManager/</guid>
      <description>一个简单的使用 JPA 插入数据的过程如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 根据 persistence-unit 的信息创建 EntityManagerFactory EntityManagerFactory factory = Persistence.createEntityManagerFactory(&amp;#34;NewPersistenceUnit&amp;#34;); // 使用 EntityManagerFactory 创建 EntityManager EntityManager manager = factory.createEntityManager(); // 使用 EntityTransaction 创建 EntityTransaction EntityTransaction transaction = manager.getTransaction(); // 开启事务 transaction.begin(); // 准备要插入的数据 Book book = new Book(); book.setName(&amp;#34;Test Book&amp;#34;); book.setPrice(12.5d); // 使用 EntityManager 持久化对象 manager.persist(book); // 提交事务 transaction.commit(); // 关闭 EntityManager 和 EntityManagerFactory manager.close(); factory.close(); EntityManagerFactory EntityManagerFactory 接口主要用来创建 EntityManager 实例</description>
    </item>
    
    <item>
      <title>Spring Awired 原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-Awired-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 23 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-Awired-%E5%8E%9F%E7%90%86/</guid>
      <description>如果组件想要使用 Spring 底层的一些组件，例如 ApplicationContext，BeanFa 等等 则可以自定义组件实现 对应的 Awired 方法，在创建对象的时候，会调用接口规定的方法注入相关的组件。通过这种方式可以将 Spring 底层的一些组件注入到自定义 Bean 中。 以 ApplicationContextAware 为例： 使用 CustomContext 类继承 ApplicationContextAware 类获取 Applicati</description>
    </item>
    
    <item>
      <title>Spring AOP 原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-AOP%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 22 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-AOP%E5%8E%9F%E7%90%86/</guid>
      <description>AOP 动态代理，指运行期间动态的将某段代码切入到指定方法指定位置进行编程的方式。主要有前置通知，后置通知，返回通知，异常通知，环绕通知几种。 如果要开启 AOP，需要添加 @EnableAspectJAutoProxy 注解。切面类需要添加 @Aspect 注解如下： 1 2 3 4 5 @Aspect @Component public class LogAspects { @Pointcut(&amp;#34;execution(public int com.xinyue.myspring.aop.MyMessage.*(..))&amp;#34;) public void pointCut() {} 被切入的 Message 类如下： 1 2 3 4 5 6 7 @Component public class MyMessage { public int sayHello(int</description>
    </item>
    
    <item>
      <title>Spring 注解 --- 自动注入</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</link>
      <pubDate>Mon, 21 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</guid>
      <description>@Autowired 自动注入对象。 默认按照类型查找类似: applicationContext.getBean(UserDao.class) 如果找到多个，则将属性名称作为 Bean Id 去容器中查找：applicationContext.getBean(&#39;userDao&#39;) 另外也可以在定义 bean 的地方添加 @Primary 注解，作为默认注入的 bean。也可以使用 @Qualifier 注解，和@Autowired 放在一起， 指定注入</description>
    </item>
    
    <item>
      <title>Spring 注解 --- 初始化、销毁及赋值</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sun, 20 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>bean 初始化和销毁方法可以通过以下四种方式指定： 通过 Spring 提供的 @Bean 属性的 initMethod 和 destoryMethod 指定 通过实现 InitializingBean, DisposableBean 接口 使用 JSR250 提供的 @PostConstruct 和 @PreDestroy 注解 使用自定义 BeanPostProcessor 对于单实例对象，容器启动的时候创建对象，创建完成调用初始化方法，容器关闭的时候（applicationContext.close();）调用销毁方法 对于多实</description>
    </item>
    
    <item>
      <title>Spring 注解 --- 组件注册</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Sat, 19 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</guid>
      <description>@Configuration 把当前文件用作配置类。 1 2 @Configuration public class MainConfig { @ComponentScan 指定扫描的包。也可以指定包含或者排除规则。 includeFilters 指定包含规则，这时需要使用 useDefaultFilters = false。 excludeFilters 指定过滤规则。 type = FilterType.CUSTOM, classes = {MyTypeFilter.class} 设置自定义规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 1. 包扫描，指定扫描的包并设置过滤规则 @Configuration @ComponentScan(value</description>
    </item>
    
    <item>
      <title>Spring 源码分析</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%BA%90%E7%A0%81/</link>
      <pubDate>Fri, 18 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%BA%90%E7%A0%81/</guid>
      <description>以 AnnotationConfigApplicationContext 为例： 创建并初始化 IOC 容器 AnnotationConfigApplicationContext() 1 2 3 4 5 6 7 8 public AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... annotatedClasses) { // 调用默认方法 this(); // 注册配置类 register(annotatedClasses); // 创建并刷新容器 refresh(); } refresh() 调用 refresh() 创建并刷新容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // 1.</description>
    </item>
    
    <item>
      <title>Spring 事务控制原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 17 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</guid>
      <description>使用 Spring 注解的方式启用事务，首先要使用 @EnableTransactionManagement 注解开启全局事务，事务需要交给具体的 TransactionManager 进行管理，所以需要向容器中添加相应的 Bean，如下所示 1 2 3 4 @Bean public PlatformTransactionManager transactionManager() throws PropertyVetoException { return new DataSourceTransactionManager(dataSource()); } 最后需要在具体需要添加事务的方法上加上 @Transactional 注解。 Spring 的事务隔离级别有以下几种： TransactionDefinition.I</description>
    </item>
    
    <item>
      <title>BeanPostProcessor 原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-BeanPostProcessor-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 16 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-BeanPostProcessor-%E5%8E%9F%E7%90%86/</guid>
      <description>BeanPostProcessor 是 Spring 提供的一个钩子，可以对新创建的 Bean 进行一些定制。例如检查标记接口和包装成为代理对象。容器能够自动检测到实现了该接口的 Bean，并应用在其他的 Bean 创建过程之中。Bean Factory 允许编程方式注册 BeanPostProcessor 用于所有通过该 BeanFactory 创建的 Bean 上。 该接口有两个方法，postProcessBeforeInitia</description>
    </item>
    
    <item>
      <title>Spring BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-BeanFactoryPostProcessor-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 15 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-BeanFactoryPostProcessor-%E5%8E%9F%E7%90%86/</guid>
      <description>BeanFactoryPostProcessor BeanFactory 的后置处理器；在 BeanFactory 标准初始化之后调用，所有 Bean 定义已经保存加载到 beanFactory 中但是 bean 的实例还未创建，可以操作 beanFactory 进行定制。为容器中添加一个自定义的 BeanFactoryPostProcessoer 如下： 1 2 3 4 5 6 7 8 9 10 11 12 @Component public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { private Log log = LogFactory.getLog(MyBeanFactoryPostProcessor.class); @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { int count = beanFactory.getBeanDefinitionCount(); log.info(&amp;#34;Count::&amp;#34; + count); String[] definitionNames = beanFactory.getBeanDefinitionNames(); log.info(&amp;#34;DefinitionNames::&amp;#34; + Arrays.toString(definitionNames)); } } BeanDefinitionRegistryPostProcessor Bean 定义注册中心的后置处理器，运行修改 bean</description>
    </item>
    
    <item>
      <title>Spring ApplicationListener 和 ApplicationEvent</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-ApplicationListener/</link>
      <pubDate>Mon, 14 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-ApplicationListener/</guid>
      <description>用于监听容器中发布的事件进而完成事件驱动模型的开发，可以自定义一个 ApplicationListener 用于监听容器中发布的事件。一个简单的自定义的 ApplicationListener 如下： 1 2 3 4 5 6 7 8 @Component public class MyApplicationListener implements ApplicationListener&amp;lt;ApplicationEvent&amp;gt; { private Log log = LogFactory.getLog(MyApplicationListener.class); @Override public void onApplicationEvent(ApplicationEvent event) { log.info(&amp;#34;event::&amp;#34; + event); } } 会打出下面两个事件： 信息: Initializing c3p0-0.9.5.4 [built 23-March-2019 23:00:48 -0700; debug? true; trace: 10] 11月 25, 2019 8:39:13 下午 com.xinyue.myspring.oth.MyApplicationListener onApplicationEvent 信息: class::class org.springframework.context.event.ContextRefreshedEvent 11月 25, 2019 8:39:13 下午 com.xinyue.myspring.oth.MyApplicationListener onApplicationEvent 信</description>
    </item>
    
    <item>
      <title>LeetCode - 今日头条</title>
      <link>https://programya.com/post/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LeetCode-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/</link>
      <pubDate>Sun, 13 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LeetCode-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/</guid>
      <description>[toc] 字符串（7） 无重复字符的最长子串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。 示例 2: 输入: &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所</description>
    </item>
    
    <item>
      <title>剑指 Offer</title>
      <link>https://programya.com/post/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%91%E6%8C%87-Offer-/</link>
      <pubDate>Sun, 13 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%91%E6%8C%87-Offer-/</guid>
      <description>剑指 Offer 简单难度 中等难度 参考：CYC 剑指 Offer 题解</description>
    </item>
    
    <item>
      <title>LeetCode 腾讯</title>
      <link>https://programya.com/post/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LeetCode-%E8%85%BE%E8%AE%AF/</link>
      <pubDate>Sat, 12 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LeetCode-%E8%85%BE%E8%AE%AF/</guid>
      <description>[toc] 数组与字符串 (18) 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 1 2 3 4 5 6 7</description>
    </item>
    
    <item>
      <title>设计模式 摘录</title>
      <link>https://programya.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%91%98%E5%BD%95/</link>
      <pubDate>Sat, 12 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%91%98%E5%BD%95/</guid>
      <description>创建型模式 工厂模式 抽象工厂模式 单例模式 建造者模式 原型模式 结构型模式 适配器模式 桥接模式 过滤器模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 行为型模式 责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 空对象模式 策略模式 模板模式 访问者模式 J2EE 模式 MVC 模式 业务代表模</description>
    </item>
    
    <item>
      <title>敏捷开发的六个原则</title>
      <link>https://programya.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 11 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/</guid>
      <description>单一职责原则（SRP） 一个类只做一件事。就一个类而言，应该仅有一个引起它变化的原因。职责就是变化的原因，如果你多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。 开放 - 闭合原则（OCP） 软件实体（类，模块，函数等等）应该可以扩展的，但是不可修改的。如果程序的一处改动就会产</description>
    </item>
    
    <item>
      <title>《代码整洁之道》读书笔记</title>
      <link>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 10 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>有意义的命名 名副其实 一个好的变量、函数或类的名字应该已经答复了所以的大问题。该告诉你为什么存在？做什么事情？应该怎样使用？ 避免误导 避免使用与本意相悖的词。例如 accountList 除非这真的是存放一组账号的 List 否则不应该使用 List 这样对程序员有特殊意义的词。 另外避免使用很长且名称相近或区别很小的名称。 做有</description>
    </item>
    
    <item>
      <title>读书笔记</title>
      <link>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 08 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>《清单革命》 清单五个原则： 权利下方 系统中各层级的权力和义务更加明确，运转效率更高。 简单至上 清单应该是简单，可测，高效。清单目的是为了简单，而不是让事情变得复杂。 激活团队 清单的制定需要提高团队的凝聚力和潜能，清单系统让整个团队迅速集结，团队成员各自发挥最大的价值，即使互相不熟悉，也</description>
    </item>
    
    <item>
      <title>关于变量命名</title>
      <link>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/</link>
      <pubDate>Mon, 07 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/</guid>
      <description>关键思想是把信息封装到名字中，清晰准确比装可爱好。 选择专业的词 例如 getPage(url) 中的 get 这个词没能表达更多的信息，无法体现具体是何处得到页面的。如果是从互联网中获取的，则使用更专业的 fetchPage 或者 downloadPage 则更为合适。 另外例如有一个 Thread 类，如下： 1 2 3 class Thread{ void stop(); } 这里的 stop 方法显然可以针对不同的作用更改为更加合适的</description>
    </item>
    
    <item>
      <title>《重构》读书笔记</title>
      <link>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 06 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>**为何重构：**重构改进软件设计，重构使软件更容易理解，重构找到Bug， 重构提高编程速度。良好的设计师快速开发的根本。 何时重构： 事不过三，三则重构 添加功能时重构 修补错误时重构 复查代码时重构 代码的坏味道 重复代码 同一个类中有两段相同的表达式：抽取方法，提炼出重复代码。 互为兄弟的子类</description>
    </item>
    
    <item>
      <title>《编写可读代码的艺术》读书笔记</title>
      <link>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 05 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>可读性基本定理，关键思想是代码的写法应当使别人理解它需要的时间最小化。其中的 理解 表示其他人能够改动它，找出缺陷并明白它如何与其他部分代码交互的。 审美 让源代码看上去养眼的三条原则： 使用一致的布局，让读者很快就习惯这种风格 让相似的代码看上去相思 把相关的代码分组，形成代码块 重新安排换行</description>
    </item>
    
    <item>
      <title>集合类 --- Set</title>
      <link>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Set/</link>
      <pubDate>Fri, 04 Jan 2019 10:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Set/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 用于存储数据的 hashMap private transient HashMap&amp;lt;E,Object&amp;gt; map; // 作为 Value 的 dummy 值 private static final Object PRESENT = new Object(); public HashSet() { // 默认的 HashMap 用于存储数据 map = new HashMap&amp;lt;&amp;gt;(); } public HashSet(Collection&amp;lt;? extends E&amp;gt; c) { // 如果初始Collection 长度的 4/3 和 16 之间的大的值作为初始化容量 map = new HashMap&amp;lt;&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } public HashSet(int initialCapacity) { map = new HashMap&amp;lt;&amp;gt;(initialCapacity); }</description>
    </item>
    
    <item>
      <title>Java HashMap</title>
      <link>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/Java-HashMap/</link>
      <pubDate>Fri, 04 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/Java-HashMap/</guid>
      <description>HashMap 是一个用于存储 Key-Value 键值对的集合，每个键值对也叫做 Node，这些键值对分散存储在一个数组中，这个数组就是 HaspMap 的骨干。HashMap 默认大小是 16，每次自动扩展或者手动初始的时候长度都是 2 的幂。HashMap 不是线程的安全的，因为在多线程的情况下可能出现循环链表的情况。 HashMap 有四种初始化方</description>
    </item>
    
    <item>
      <title>集合类 --- Map</title>
      <link>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Map/</link>
      <pubDate>Fri, 04 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Map/</guid>
      <description>HashMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139</description>
    </item>
    
    <item>
      <title>集合类 --- List</title>
      <link>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-List/</link>
      <pubDate>Fri, 04 Jan 2019 08:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-List/</guid>
      <description>ArrayList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139</description>
    </item>
    
    <item>
      <title>Java 8 Stream</title>
      <link>https://programya.com/post/Java/JDK8/Java-8-Stream/</link>
      <pubDate>Thu, 03 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JDK8/Java-8-Stream/</guid>
      <description>流与集合 流 流是 Java 的新 API，允许以声明的方式处理集合。简单来说你可以把流看作是遍历数据集的高级迭代器。此外流还可以透明的并行处理。Java 8的集合支持一个新的 stream 方法，这个方法会返回一个流。 流与集合 粗略的来说流与集合的差异在于什么时候进行计算。集合是一个内存数据结构，包含数据结构中</description>
    </item>
    
    <item>
      <title>Java 8 Lambda</title>
      <link>https://programya.com/post/Java/JDK8/Java-8-Lambda/</link>
      <pubDate>Thu, 03 Jan 2019 08:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JDK8/Java-8-Lambda/</guid>
      <description>在编程中可以利用行为参数化来传递代码有助于应对不断变化的需求，即定义一个代码块来表示一个行为，然后传递这个行为。你可以决定在某一个事件发生的时候或者算法中的某个特定的时刻运行该代码，进而编写更为灵活且可重复的代码。而 Lambda 表达式可以让你简洁的表示一个行为或传递代码。Lambda 表达式</description>
    </item>
    
    <item>
      <title>Java ConcurrentHashMap</title>
      <link>https://programya.com/post/Java/JUC/Java-ConcurrentHashMap/</link>
      <pubDate>Wed, 02 Jan 2019 10:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JUC/Java-ConcurrentHashMap/</guid>
      <description>JDK 8 中 ConcurrentHashMap 为什么放弃分段锁 在 Java 8 中 ConcurrentHashMap 放弃了分段锁而是使用 synchronized 加 CAS 的来实现并发控制的。一方面是 JVM 对 synchronized 已经进行了大量的优化措施，例如锁粗化，锁消除，自适应自旋锁，偏向锁等等。另一方面使用分段锁浪费内存空间，且 map 放入时竞争同一个锁的概率很小，分段锁反而可能造成更新操作长时间等待，同时为了提</description>
    </item>
    
    <item>
      <title>Java CAS</title>
      <link>https://programya.com/post/Java/JUC/Java-CAS/</link>
      <pubDate>Wed, 02 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JUC/Java-CAS/</guid>
      <description>CAS ( Compare And Swap ) 比较并交换，是一条 CPU 并发原语。其作用是判断内存某个位置的值是否为预期值，如果是则更改为新值，这个过程是原子的。 CAS CAS 并发原语体现在 Java 预言中就是 sun.misc.Unsafe 类中各个方法。调用 Unsafe 类中的 CAS 方法， JVM 会帮我们实现出 CAS 汇编指令。这是一种依赖于硬件的功能，通过它实现了原子操作。由于 CAS 是一种传统</description>
    </item>
    
    <item>
      <title>Java volatile</title>
      <link>https://programya.com/post/Java/JUC/Java-volatile/</link>
      <pubDate>Wed, 02 Jan 2019 08:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JUC/Java-volatile/</guid>
      <description>JMM JVM: Java 虚拟机 JMM: Java 内存模型 Java 内存模型 Java Memory Model 本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中的各个变量（包括实例字段、静态字段和构成数组对象元素）的访问方式。 JMM 关于同步的规定： 线程解锁前，必须把共享变量的值刷回主内存 线程加锁前，必须读取主内存到自己</description>
    </item>
    
    <item>
      <title>Java ReentrantLock</title>
      <link>https://programya.com/post/Java/JUC/Java-ReentrantLock/</link>
      <pubDate>Tue, 01 Jan 2019 23:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JUC/Java-ReentrantLock/</guid>
      <description>ReentrantLock 重入锁，即支持重复进入的锁，该锁能够支持一个线程对一个资源反复的加锁。实现可重入锁需要解决两个问题： 线程再次获取锁。锁需要识别获取锁的线程是否是当前占用锁的线程，如果是则成功获取。 锁的最终释放。线程重复多次获取锁，那么需要在相同次数释放该锁后，其他线程能更获取到该锁。加锁时计数</description>
    </item>
    
    <item>
      <title>Java 并发控制</title>
      <link>https://programya.com/post/Java/JUC/Java-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 01 Jan 2019 22:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JUC/Java-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>锁 公平锁和非公平锁 并发包中 ReentrantLock 的创建可以指定构造函数的 boolean 类型来得到公平锁赫尔非公平锁，默认是非公平锁。 二者区别 **公平锁：**Thread acquire a fair lock in the order in which they request it. 公平锁：在并发环境中，每个线程在获取锁时先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个就占用锁，否则</description>
    </item>
    
    <item>
      <title>Java AQS</title>
      <link>https://programya.com/post/Java/JUC/Java-AQS/</link>
      <pubDate>Tue, 01 Jan 2019 21:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Java/JUC/Java-AQS/</guid>
      <description>众所周知 synchronized 是重量级锁，虽然在 JDK 1.6 后使用了轻量级锁，偏向锁，自适应自旋锁，锁粗化，锁消除等手段去去优化，但是其基于 JVM 的隐式获取和释放锁的方式导致缺少了获取锁和释放锁的可操作性。如果需要高效的实现锁并操作获取和释放锁的过程则需要使用显式锁 Lock，而其中 JUC 包下的 AQS 类是很多锁组件的基础</description>
    </item>
    
    <item>
      <title>Initial</title>
      <link>https://programya.com/post/README/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/README/</guid>
      <description>Initial </description>
    </item>
    
    <item>
      <title></title>
      <link>https://programya.com/post/Java/Java-%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://programya.com/post/Java/Java-%E8%AF%81%E4%B9%A6/</guid>
      <description>HTTP HTTPS 证书分类 KeyTools</description>
    </item>
    
  </channel>
</rss>