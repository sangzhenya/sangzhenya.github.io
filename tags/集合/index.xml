<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>集合 on 新月的博客</title>
    <link>http://programya.com/tags/%E9%9B%86%E5%90%88/</link>
    <description>Recent content in 集合 on 新月的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 04 Jan 2019 10:00:00 +0800</lastBuildDate>
    
	<atom:link href="http://programya.com/tags/%E9%9B%86%E5%90%88/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>集合类 --- Set</title>
      <link>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Set/</link>
      <pubDate>Fri, 04 Jan 2019 10:00:00 +0800</pubDate>
      
      <guid>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Set/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 用于存储数据的 hashMap private transient HashMap&amp;lt;E,Object&amp;gt; map; // 作为 Value 的 dummy 值 private static final Object PRESENT = new Object(); public HashSet() { // 默认的 HashMap 用于存储数据 map = new HashMap&amp;lt;&amp;gt;(); } public HashSet(Collection&amp;lt;? extends E&amp;gt; c) { // 如果初始Collection 长度的 4/3 和 16 之间的大的值作为初始化容量 map = new HashMap&amp;lt;&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } public HashSet(int initialCapacity) { map = new HashMap&amp;lt;&amp;gt;(initialCapacity); }</description>
    </item>
    
    <item>
      <title>Java HashMap</title>
      <link>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/Java-HashMap/</link>
      <pubDate>Fri, 04 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/Java-HashMap/</guid>
      <description>HashMap 是一个用于存储 Key-Value 键值对的集合，每个键值对也叫做 Node，这些键值对分散存储在一个数组中，这个数组就是 HaspMap 的骨干。HashMap 默认大小是 16，每次自动扩展或者手动初始的时候长度都是 2 的幂。HashMap 不是线程的安全的，因为在多线程的情况下可能出现循环链表的情况。 HashMap 有四种初始化方</description>
    </item>
    
    <item>
      <title>集合类 --- Map</title>
      <link>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Map/</link>
      <pubDate>Fri, 04 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-Map/</guid>
      <description>HashMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139</description>
    </item>
    
    <item>
      <title>集合类 --- List</title>
      <link>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-List/</link>
      <pubDate>Fri, 04 Jan 2019 08:00:00 +0800</pubDate>
      
      <guid>http://programya.com/post/Java/%E9%9B%86%E5%90%88%E7%B1%BB/%E9%9B%86%E5%90%88%E7%B1%BB-List/</guid>
      <description>ArrayList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139</description>
    </item>
    
    <item>
      <title>Java ConcurrentHashMap</title>
      <link>http://programya.com/post/Java/JUC/Java-ConcurrentHashMap/</link>
      <pubDate>Wed, 02 Jan 2019 10:00:00 +0800</pubDate>
      
      <guid>http://programya.com/post/Java/JUC/Java-ConcurrentHashMap/</guid>
      <description>JDK 8 中 ConcurrentHashMap 为什么放弃分段锁 在 Java 8 中 ConcurrentHashMap 放弃了分段锁而是使用 synchronized 加 CAS 的来实现并发控制的。一方面是 JVM 对 synchronized 已经进行了大量的优化措施，例如锁粗化，锁消除，自适应自旋锁，偏向锁等等。另一方面使用分段锁浪费内存空间，且 map 放入时竞争同一个锁的概率很小，分段锁反而可能造成更新操作长时间等待，同时为了提</description>
    </item>
    
  </channel>
</rss>