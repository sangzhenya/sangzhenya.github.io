+++
title="DEMO"
tags=["hahaah"]
categories=["hahaah"]
date="2019-12-13T21:00:00+08:00"
toc=true
+++

## 经典算法

[toc]

### 字符串（7）

#### 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

---

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] imap = new int[128];
        int res = 0;
        int lastIndex = 0;
        for (int i = 0; i < s.length(); i++) {
            // 上次出现的位置，记录最后一次出现重复的值的位置
            lastIndex = Math.max(imap[s.charAt(i)], lastIndex);
            // 更新结果
            res = Math.max(i - lastIndex + 1, res);
            // 更新上次出现的位置
            imap[s.charAt(i)] = i + 1;
        }
        return res;
    }
}
```

#### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1:**

```
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例 2:**

```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明:**

所有输入只包含小写字母 `a-z` 。

---

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while(strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.equals("")) {
                    return "";
                }
            }
        }
        return prefix;
    }
}
```

#### 字符串的排列

给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

**示例1:**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

 

**示例2:**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

 

**注意：**

1. 输入的字符串只包含小写字母
2. 两个字符串的长度都在 [1, 10,000] 之间

---

```java
class Solution {
    // 主要思路是使用数组记录 string 中 char 的元素个数是否相等
    public boolean checkInclusion(String s1, String s2) {
        char[] a1 = new char[26];
        // 收集 s1 中的 char 
        for (char c : s1.toCharArray()) {
            a1[c - 'a'] += 1;
        }
        char[] a2 = new char[26];
        int l1 = s1.length();
        // 收集 s2 中的 char 保证仅收集和 s1 长度相等的部分，且同时判断两个数组是否相等
        for (int i = 0; i < s2.length(); i++) {
            if (i - l1 >= 0) {
                a2[s2.charAt(i - l1) - 'a'] -= 1;
            }
            a2[s2.charAt(i) - 'a'] += 1;
            if (Arrays.equals(a1, a2)) {
                return true;
            }
        }
        return false;
    }
}
```





### 数组与排序（10）

### 链表或树（9）

### 动态与贪心（6）

### 数据结构（3）

### 扩展练习（3）



