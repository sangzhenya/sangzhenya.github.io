<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on 新月的博客</title>
    <link>https://programya.com/categories/Spring/</link>
    <description>Recent content in Spring on 新月的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 15 Feb 2020 09:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://programya.com/categories/Spring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring Security</title>
      <link>https://programya.com/post/Spring/Spring-Security/Spring-Security/</link>
      <pubDate>Sat, 15 Feb 2020 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Security/Spring-Security/</guid>
      <description>[toc] 权限相关概念 权限管理一般是值根据系统设置的安全规则或者安全策略，用户只能访问被授权的资源。权限管理的前置条件是用户和密码的认证系统。其中认证 是通过用户名和密码成功登陆系统后，让系统得到当前用户的角色身份；授权 则是系统根据当前用户的角色，给其授予可以操作的的权限资源。 主要有三个对</description>
    </item>
    
    <item>
      <title>Spring Cloud Eureka</title>
      <link>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Fri, 15 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Eureka-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</guid>
      <description>Eureka 是 Netflix 的一个子模块，也是核心模块之一。Eureka 是一个基于 REST 的服务，用于定位服务，实现云端中间层服务发现与故障转移。服务注册与发现对于微服务是非常的重要的，有了服务注册与发现只需要使用服务的标识符，就昆虫访问到服务，而不需要修改服务调用的配置文件。功能和 Dubbo 的注册中心类似。Eur</description>
    </item>
    
    <item>
      <title>Spring Cloud Ribbon Feign Hystrix Zuul</title>
      <link>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
      <pubDate>Wed, 13 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
      <description>Ribbon Spring Cloud Ribbon 是基于 Netflix Ribbon 实现一套客户端负载均衡的工具。Ribbon 是 Netflix 发布的开源项目，其主要功能是提供客户端的负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 客户端组件提供了一系列完善的配置项如连接超时，重试等。简单的说就是在配置文件中列出 Load Balancer 后面所有的服务，Ribbon 会自动的</description>
    </item>
    
    <item>
      <title>Spring Cloud Config Server</title>
      <link>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-ConfigServer/</link>
      <pubDate>Mon, 11 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Cloud/Spring-Cloud-ConfigServer/</guid>
      <description>微服务意味着将单体应用的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式，动态的配置管理是必要的。Spring Cloud 提供了 Config Server 来解决这个问题，其为微服务架构中的微服务提供集中化的外部配置支持，配置服务</description>
    </item>
    
    <item>
      <title>Spring Boot MyBatis 多数据源配置</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-MyBatis-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 09 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-MyBatis-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</guid>
      <description>主要有两种配置方式：第一种是自定义配置 SqlSessionFactory ，第二种是使用 AbstractRoutingDataSource + AOP 的方式实现 自定义 SqlSessionFactory 首先关闭 Spring Boot 对于 DataSourceAutoConfiguration: 1 2 3 @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class }) 然后配置 DataSourceConfig，例如这边有两个数据库连接： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class DataSourceConfig { @Bean(name = &amp;#34;db1&amp;#34;) @ConfigurationProperties(prefix = &amp;#34;spring.datasource.db1&amp;#34;) public DataSource db1Source() { return DataSourceBuilder.create().build(); } @Bean(name = &amp;#34;db2&amp;#34;) @ConfigurationProperties(prefix = &amp;#34;spring.datasource.db2&amp;#34;) public DataSource db2Source() { return DataSourceBuilder.create().build(); } } 然后在配</description>
    </item>
    
    <item>
      <title>Spring Boot Actuator</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-Actuator/</link>
      <pubDate>Thu, 07 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-Actuator/</guid>
      <description>通过引入 spring-boot-starter-actuator 可以使用 Spring Boot 为我们提供的应用的监控和管理功能。可以通过 HTTP，JMX，SSH 协议进行操作，自动得到审计、健康及指标信息。pom 文件中设置如下： 1 2 3 4 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 主要有以下一些内容： /actuator 启用了哪些 actuator /actuator/beans 容器中每个组件的定义信息 /actuator/caches 容器中的 Cache 信息 /actuator/caches/{cache} 容器中具体 Cache 的缓存条目 /actuator/health/{*path} 和 /actuator/health 应用</description>
    </item>
    
    <item>
      <title>Spring Boot 自动配置</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 05 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>众所周知 Spring Boot 极大的减少了 Spring 繁琐的配置，采用约定大于配置的策略。也是基于此 Spring Boot 有很多自动配置的逻辑，下面简单理一下相关的代码。 首先对于 Spring Boot 应用主启动类上要标注 @SpringBootApplication 如下所示，那么这个注解为会 Spring Boot 添加哪些配置的呢？下面可以看一下相关的源码。 1 2 3 4 5 6 @SpringBootApplication public class MyMainApplication { public static void main(String[] args) { SpringApplication.run(MyMainApplication.class); } } 引入如下</description>
    </item>
    
    <item>
      <title>Spring Boot 自定义 Starter</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89-Starter/</link>
      <pubDate>Sun, 03 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89-Starter/</guid>
      <description>Starter 只是用来引入自动配置模块，Starter 依赖自动配置，其他人使用的时候只需要引入 Starter 即可。另外对于我们自己实现的 Starter 推荐命名是 xxx-spring-boot-starter。 首先创建一个空项目例如 mystarter, 打开项目创建两个 Module，一个是普通的 Maven 项目，一个是 Spring Boot 项目。如下图所示： 对于 Starter</description>
    </item>
    
    <item>
      <title>Spring Boot 使用外部容器</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8-Servlet-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 01 Mar 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8-Servlet-%E5%AE%B9%E5%99%A8/</guid>
      <description>基本项目创建 在创建项目的时候使用 war 的方式打包： 其实主要的 pom 文件的配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;webwar&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;!--打包方式设置为 war--&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;!--将内置的 Tomcat 设置为 provided --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 在主目录下编写 SpringBootServletInitializer 的子类并实现其 configure 方法，样例如下： 1 2 3 4 5 6 7 public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { // 将 主类作为参</description>
    </item>
    
    <item>
      <title>Spring Boot 日志</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 25 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>开发用到的框架大概有：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j&amp;hellip;.。其中 JCL， SLF4J， Jboss-logging 是日志门面，log4j, jul, log4j, Logback 是日志的实现. Spring Boot 选用的是 SLF4J 和 Logback 的实现。依赖如下： 在自己的系统中使用 slf4j 的话首先要导入 slf4j</description>
    </item>
    
    <item>
      <title>Spring Boot 嵌入式容器</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 23 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/</guid>
      <description>对于嵌入式容器的配置 Spring 的基本的 Server 的配置都可以在 application.yaml 中通过 server 相关的属性进行配置。 其对应的配置类是 1 2 3 4 5 6 7 8 9 10 11 @ConfigurationProperties(prefix = &amp;#34;server&amp;#34;, ignoreUnknownFields = true) public class ServerProperties { private final Tomcat tomcat = new Tomcat(); public static class Tomcat { private final Accesslog accesslog = new Accesslog(); private String protocolHeader; private String protocolHeaderHttpsValue = &amp;#34;https&amp;#34;; private String portHeader = &amp;#34;X-Forwarded-Port&amp;#34;; } } 其内部类 Tomcat 用户配置 Tomcat 相关的信息。在 ServletWebServerFactoryCustomizer 会使用 其中的配置对 嵌入式容器进行配置， 同样</description>
    </item>
    
    <item>
      <title>Spring Boot 缓存</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E7%BC%93%E5%AD%98/</link>
      <pubDate>Thu, 21 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E7%BC%93%E5%AD%98/</guid>
      <description>JSR 107 首先 JSR 107 即 JCache API的首个早期草案，在 Java JCache 中定义了 5 个核心内容，即 CachingProvider，CacheMaager，Cache，Entry 和 Expiry。 CachingProvider 中定义了创建、配置、获取、管理和控制多个 CacheManager, 一个应用可以在运行期间访问多个 CahingProvider。 CacheManger 定义了创建、</description>
    </item>
    
    <item>
      <title>Spring Boot 配置文件</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 19 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>Spring Boot 默认使用 properties 文件来配置属性，也可以使用 YAML 文件进行配置。YAML 以数据为中心，比 json 和 xml 等更适合做配置文件。 基本语法 K:[空格]V 表示一对键值对。以空格的缩进控制层级关系, 属性和值均是大小写敏感的，只要是左对齐的一列数据，都是同一个层级的。 1 2 server:port:8080 普通值 数字 字符串 布尔 字符串默认不用加</description>
    </item>
    
    <item>
      <title>Spring Boot 错误处理机制</title>
      <link>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 17 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Boot/Spring-Boot-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</guid>
      <description>Spring 针对于浏览器访问和客户端访问使用不同的处理逻辑。如果是浏览器则返回一个出错的网页，而如果是客户端则返回 JSON 格式的错误数据。其处理的原理如下： 在 ErrorMvcAutoConfiguration 有对于出错处理的自动配置。其为容器中添加了 DefaultErrorAttributes Bean 在页面中共享信息。 1 2 3 4 5 @Bean @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); } 此外为容器中添加了 BasicErrorController Bean，处</description>
    </item>
    
    <item>
      <title>Spring Security 入门</title>
      <link>https://programya.com/post/Spring/Spring-Security/Spring-Security-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 15 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Security/Spring-Security-%E5%85%A5%E9%97%A8/</guid>
      <description>Spring Security 就是通过一条过滤器链使用认证和授权的工作。如下图所示： 其中 FilterSecurityInterceptor 中会根据 config 配置的内容，判断是否可以访问对应的资源，如果不可以则会抛出异常。然后在 ExceptionTranslationFilter 中会捕获异常并作出响应的处理。 Spring Security 几个重要的概念如下： SecurityContextHolder Spring Security 提供的 SecurityContextHolder 类让程序可以方便访问 SecurityContext。其采用的是 ThreadLocal 方</description>
    </item>
    
    <item>
      <title>Spring MVC Web 组件</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Web-%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 13 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Web-%E7%BB%84%E4%BB%B6/</guid>
      <description>Web 主要有三个组件，分别是 servlet, filter, listener. Servlet 其主要作用是处理客户端请求的动态资源。Servlet 通常需要接受请求，处理请求，完成响应。其生命周期分为四个阶段，1 调用构造方法实例化，2 调用 init 方法初始化，3 处理请求调用 Service 方法，4 服务终止 调用 destory 方法。在 web.xml 配置一个简单的 Servlet 如下： 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    
    <item>
      <title>Spring MVC Model And View</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Model-And-View/</link>
      <pubDate>Mon, 11 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-Model-And-View/</guid>
      <description>Spring MVC 在 ModelAndView 上添加数据主要以下三个方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public ModelAndView addObject(Object attributeValue) { // 调用添加数据的方法 getModelMap().addAttribute(attributeValue); return this; } public ModelMap addAttribute(Object attributeValue) { Assert.notNull(attributeValue, &amp;#34;Model object must not be null&amp;#34;); // 如果为空则直接返回 if (attributeValue instanceof Collection &amp;amp;&amp;amp; ((Collection&amp;lt;?&amp;gt;) attributeValue).isEmpty()) { return this; } // 根据数据类型获取类名作为参数名称 return addAttribute(Conventions.getVariableName(attributeValue), attributeValue); } public ModelMap addAttribute(String attributeName, @Nullable Object attributeValue) { Assert.notNull(attributeName, &amp;#34;Model attribute name</description>
    </item>
    
    <item>
      <title>Spring MVC 自定义拦截器</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Sat, 09 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>Spring MVC 也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现 HandlerInterceptor 接口，其主要有三个方法： preHandle() 这个方法再业务处理请求之前被调用，在该方法中对用户请求 request 进行处理，如果需要该拦截器对请求进行拦截处理后还要调用其他拦截器或者业务方法进行处理则返回 tru</description>
    </item>
    
    <item>
      <title>Spring MVC @RequestMapping 注解</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Thu, 07 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E6%B3%A8%E8%A7%A3/</guid>
      <description>SpringMVC 使用 @RequestMapping 注解为控制器指定可以处理哪些 URL 请求，在 Controller 的类和方法上都可以使用该注解，标记在类上提供初步的请求映射信息，相对于 Web 应用的根目录。标记在方法上提供进一步细分映射信息，对于标记在类上的 URL，如果方法所在的类未标注则 URL 是相对于 Web 应用的根目录。在 DispatcherServlet 截获请求后，就通过 @RequestMapping 提供的映射信</description>
    </item>
    
    <item>
      <title>Spring MVC 运行流程</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 05 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid>
      <description>调用的起点是 org.springframework.web.servlet.DispatcherServlet#doService 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // DispatcherServlet protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) { attributesSnapshot = new HashMap&amp;lt;&amp;gt;(); Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) { String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) { attributesSnapshot.put(attrName, request.getAttribute(attrName)); } } } // Make framework objects available to handlers and view objects. // 在 request</description>
    </item>
    
    <item>
      <title>Spring MVC 异步处理</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</link>
      <pubDate>Sun, 03 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-MVC-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</guid>
      <description>在 Servlet 3.0 的时候增加了对异步的支持，在此之前 Servlet 采用 Thread Per Request 的方式处理请求。即如果一个请求如果进行耗时的操作例如 IO，数据库或者调用第三方的接口等等，其所对应的的线程将同步的等待响应操作的完成，所以此时线程并不能即使的释放线程放回线程池以供后续使用，在并发量大的情况下，这会带来性能问题。</description>
    </item>
    
    <item>
      <title>Spring 和 Spring MVC 整合</title>
      <link>https://programya.com/post/Spring/Spring-MVC/Spring-%E5%92%8C-Spring-MVC%E6%95%B4%E5%90%88/</link>
      <pubDate>Fri, 01 Feb 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-MVC/Spring-%E5%92%8C-Spring-MVC%E6%95%B4%E5%90%88/</guid>
      <description>Web 容器启动的时候会扫描每个 jar 包下的 META-INF\services\javax.servlet.ServletContainerInitializer 文件中的内容，根据文件中的定义全类名找到 ServletContainerInitializer 的子类，然后调用其 onStartup 方法。在引入的 spring-web 下就有这样的一个文件，其内容是 org.springframework.web.SpringServletContainerInitializer， 即定义了一个 Spri</description>
    </item>
    
    <item>
      <title>Spring Data</title>
      <link>https://programya.com/post/Spring/Spring-Data/Spring-Data/</link>
      <pubDate>Mon, 28 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/Spring-Data/</guid>
      <description>Spring Data 用于简化数据库访问，能够减少数据访问层的开发量，只需要声明持久层接口，其他都由 Spring Data JPA 完成。支持 NoSQL 和 关系数据存储，主要目的是使数据库的访问变得更加便捷。支持的 NoSQL 有 MongoDB， Neo4j, Redis 和 Hbase，支持数据库存储技术有 JDBC 和 JPA。 Repository 是一个空接口即标记接口，如果定义的接口继承了 Repository 则</description>
    </item>
    
    <item>
      <title>JPA JPQL</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPQL/</link>
      <pubDate>Sun, 27 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPQL/</guid>
      <description>JPQL 语言，即 Java Persistence Query Language 是一种和 SQL 非常相似的中间性和对象查询语言，其最终会被编译成针对于不同底层数据库的 SQL 查询，从而屏蔽掉不同数据库的差异。JPQL 的语句都是通过 Query 接口封装执行的。 Query 接口主要有以下几个方法： int executeUpdate(); 执行 Update 或者 Delete 语句。 List getResultList(); 执行 Select 语句并返回结果实体列表。 Object getSingleResult(); 用于执行只返回单个结</description>
    </item>
    
    <item>
      <title>JPA 映射关系</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPA-%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sat, 26 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPA-%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</guid>
      <description>对于一对多的情况使用一个 Department 类和一个 Student 类。 单向多对一 在多的一端（Student）维护数据，则需要在多的一端设置如下的注解： 1 2 3 4 5 6 7 8 9 10 11 12 private Department department; // 设置多对一，且设置懒加载 @ManyToOne(fetch = FetchType.LAZY) // 设置 Mapping 列的名称 @JoinColumn(name = &amp;#34;department_id&amp;#34;) public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } 在插入的时候最好先插入一的一端，再插入多的一</description>
    </item>
    
    <item>
      <title>JPA 基本注解</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPA-%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 25 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPA-%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3/</guid>
      <description>JDBC 是 Sun公司提供了一套访问数据库的接口规范，数据库厂商必须遵守Sun公司的规范，提供访问自己数据库服务器API即驱动；JDBC只是一些接口，需要数据库厂商提供相应的实现类即驱动，如果没有驱动无法连接数据库，更无法操作数据库。 JPA 即 Java Persistence API，用于对象持久化的 API 是一个规范，Java</description>
    </item>
    
    <item>
      <title>JPA EntityManager</title>
      <link>https://programya.com/post/Spring/Spring-Data/JPA-EntityManager/</link>
      <pubDate>Thu, 24 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Data/JPA-EntityManager/</guid>
      <description>一个简单的使用 JPA 插入数据的过程如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 根据 persistence-unit 的信息创建 EntityManagerFactory EntityManagerFactory factory = Persistence.createEntityManagerFactory(&amp;#34;NewPersistenceUnit&amp;#34;); // 使用 EntityManagerFactory 创建 EntityManager EntityManager manager = factory.createEntityManager(); // 使用 EntityTransaction 创建 EntityTransaction EntityTransaction transaction = manager.getTransaction(); // 开启事务 transaction.begin(); // 准备要插入的数据 Book book = new Book(); book.setName(&amp;#34;Test Book&amp;#34;); book.setPrice(12.5d); // 使用 EntityManager 持久化对象 manager.persist(book); // 提交事务 transaction.commit(); // 关闭 EntityManager 和 EntityManagerFactory manager.close(); factory.close(); EntityManagerFactory EntityManagerFactory 接口主要用来创建 EntityManager 实例</description>
    </item>
    
    <item>
      <title>Spring Awired 原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-Awired-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 23 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-Awired-%E5%8E%9F%E7%90%86/</guid>
      <description>如果组件想要使用 Spring 底层的一些组件，例如 ApplicationContext，BeanFa 等等 则可以自定义组件实现 对应的 Awired 方法，在创建对象的时候，会调用接口规定的方法注入相关的组件。通过这种方式可以将 Spring 底层的一些组件注入到自定义 Bean 中。 以 ApplicationContextAware 为例： 使用 CustomContext 类继承 ApplicationContextAware 类获取 Applicati</description>
    </item>
    
    <item>
      <title>Spring AOP 原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-AOP%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 22 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-AOP%E5%8E%9F%E7%90%86/</guid>
      <description>AOP 动态代理，指运行期间动态的将某段代码切入到指定方法指定位置进行编程的方式。主要有前置通知，后置通知，返回通知，异常通知，环绕通知几种。 如果要开启 AOP，需要添加 @EnableAspectJAutoProxy 注解。切面类需要添加 @Aspect 注解如下： 1 2 3 4 5 @Aspect @Component public class LogAspects { @Pointcut(&amp;#34;execution(public int com.xinyue.myspring.aop.MyMessage.*(..))&amp;#34;) public void pointCut() {} 被切入的 Message 类如下： 1 2 3 4 5 6 7 @Component public class MyMessage { public int sayHello(int</description>
    </item>
    
    <item>
      <title>Spring 注解 --- 自动注入</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</link>
      <pubDate>Mon, 21 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</guid>
      <description>@Autowired 自动注入对象。 默认按照类型查找类似: applicationContext.getBean(UserDao.class) 如果找到多个，则将属性名称作为 Bean Id 去容器中查找：applicationContext.getBean(&#39;userDao&#39;) 另外也可以在定义 bean 的地方添加 @Primary 注解，作为默认注入的 bean。也可以使用 @Qualifier 注解，和@Autowired 放在一起， 指定注入</description>
    </item>
    
    <item>
      <title>Spring 注解 --- 初始化、销毁及赋值</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sun, 20 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>bean 初始化和销毁方法可以通过以下四种方式指定： 通过 Spring 提供的 @Bean 属性的 initMethod 和 destoryMethod 指定 通过实现 InitializingBean, DisposableBean 接口 使用 JSR250 提供的 @PostConstruct 和 @PreDestroy 注解 使用自定义 BeanPostProcessor 对于单实例对象，容器启动的时候创建对象，创建完成调用初始化方法，容器关闭的时候（applicationContext.close();）调用销毁方法 对于多实</description>
    </item>
    
    <item>
      <title>Spring 注解 --- 组件注册</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Sat, 19 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%B3%A8%E8%A7%A3-%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</guid>
      <description>@Configuration 把当前文件用作配置类。 1 2 @Configuration public class MainConfig { @ComponentScan 指定扫描的包。也可以指定包含或者排除规则。 includeFilters 指定包含规则，这时需要使用 useDefaultFilters = false。 excludeFilters 指定过滤规则。 type = FilterType.CUSTOM, classes = {MyTypeFilter.class} 设置自定义规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 1. 包扫描，指定扫描的包并设置过滤规则 @Configuration @ComponentScan(value</description>
    </item>
    
    <item>
      <title>Spring 源码分析</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E6%BA%90%E7%A0%81/</link>
      <pubDate>Fri, 18 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E6%BA%90%E7%A0%81/</guid>
      <description>以 AnnotationConfigApplicationContext 为例： 创建并初始化 IOC 容器 AnnotationConfigApplicationContext() 1 2 3 4 5 6 7 8 public AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... annotatedClasses) { // 调用默认方法 this(); // 注册配置类 register(annotatedClasses); // 创建并刷新容器 refresh(); } refresh() 调用 refresh() 创建并刷新容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // 1.</description>
    </item>
    
    <item>
      <title>Spring 事务控制原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 17 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</guid>
      <description>使用 Spring 注解的方式启用事务，首先要使用 @EnableTransactionManagement 注解开启全局事务，事务需要交给具体的 TransactionManager 进行管理，所以需要向容器中添加相应的 Bean，如下所示 1 2 3 4 @Bean public PlatformTransactionManager transactionManager() throws PropertyVetoException { return new DataSourceTransactionManager(dataSource()); } 最后需要在具体需要添加事务的方法上加上 @Transactional 注解。 Spring 的事务隔离级别有以下几种： TransactionDefinition.I</description>
    </item>
    
    <item>
      <title>BeanPostProcessor 原理</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-BeanPostProcessor-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 16 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-BeanPostProcessor-%E5%8E%9F%E7%90%86/</guid>
      <description>BeanPostProcessor 是 Spring 提供的一个钩子，可以对新创建的 Bean 进行一些定制。例如检查标记接口和包装成为代理对象。容器能够自动检测到实现了该接口的 Bean，并应用在其他的 Bean 创建过程之中。Bean Factory 允许编程方式注册 BeanPostProcessor 用于所有通过该 BeanFactory 创建的 Bean 上。 该接口有两个方法，postProcessBeforeInitia</description>
    </item>
    
    <item>
      <title>Spring BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-BeanFactoryPostProcessor-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 15 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-BeanFactoryPostProcessor-%E5%8E%9F%E7%90%86/</guid>
      <description>BeanFactoryPostProcessor BeanFactory 的后置处理器；在 BeanFactory 标准初始化之后调用，所有 Bean 定义已经保存加载到 beanFactory 中但是 bean 的实例还未创建，可以操作 beanFactory 进行定制。为容器中添加一个自定义的 BeanFactoryPostProcessoer 如下： 1 2 3 4 5 6 7 8 9 10 11 12 @Component public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor { private Log log = LogFactory.getLog(MyBeanFactoryPostProcessor.class); @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { int count = beanFactory.getBeanDefinitionCount(); log.info(&amp;#34;Count::&amp;#34; + count); String[] definitionNames = beanFactory.getBeanDefinitionNames(); log.info(&amp;#34;DefinitionNames::&amp;#34; + Arrays.toString(definitionNames)); } } BeanDefinitionRegistryPostProcessor Bean 定义注册中心的后置处理器，运行修改 bean</description>
    </item>
    
    <item>
      <title>Spring ApplicationListener 和 ApplicationEvent</title>
      <link>https://programya.com/post/Spring/Spring-Core/Spring-ApplicationListener/</link>
      <pubDate>Mon, 14 Jan 2019 09:00:00 +0800</pubDate>
      
      <guid>https://programya.com/post/Spring/Spring-Core/Spring-ApplicationListener/</guid>
      <description>用于监听容器中发布的事件进而完成事件驱动模型的开发，可以自定义一个 ApplicationListener 用于监听容器中发布的事件。一个简单的自定义的 ApplicationListener 如下： 1 2 3 4 5 6 7 8 @Component public class MyApplicationListener implements ApplicationListener&amp;lt;ApplicationEvent&amp;gt; { private Log log = LogFactory.getLog(MyApplicationListener.class); @Override public void onApplicationEvent(ApplicationEvent event) { log.info(&amp;#34;event::&amp;#34; + event); } } 会打出下面两个事件： 信息: Initializing c3p0-0.9.5.4 [built 23-March-2019 23:00:48 -0700; debug? true; trace: 10] 11月 25, 2019 8:39:13 下午 com.xinyue.myspring.oth.MyApplicationListener onApplicationEvent 信息: class::class org.springframework.context.event.ContextRefreshedEvent 11月 25, 2019 8:39:13 下午 com.xinyue.myspring.oth.MyApplicationListener onApplicationEvent 信</description>
    </item>
    
  </channel>
</rss>